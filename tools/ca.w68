@1Introduction.
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

@m cvs ca = "$Id: $"

@a@<Prelude@>
BEGIN
@<Included declarations@>
@<Plain values in the outer reach@>
@<Names in the outer reach@>
@<Operators in the outer reach@>
@<Procedures in the outer reach@>
@<Logic in the outer reach@>
END
@<Postlude@>

@ The local compiler requires a special prelude.@^system dependencies@>

@<Prel...@>=
PROGRAM ca CONTEXT VOID
USE @<Library preludes@>

@ And a special postlude.@^system dependencies@>

@<Post...@>=
FINISH

@ Only the standard prelude is required.

@<Library...@>=
standard

@ The program will need some operators and procedures from the general
and system preludes.

@isysprelude.w@>

@2Program purpose.
The program is designed to reduce the complexity of processing Algol
68 source files. It also will process Web 68 source files. When an
Algol 68 program is compiled, the compiler (a68toc) requires a number
of arguments. This program (ca) helps the user to create these
arguments. It will also process Web 68 source files using the
preprocessor 'tang'.

Here are some examples of calling 'ca':
<dl>
   <dt>ca prog.w68</dt>
   <dd>Preprocess the Web 68 source file with 'tang', searching the
      default directories for included files (the default directory
      built-in to 'tang' is ${HOME}/lib)<!--$-->, putting the Algol 68 output
      in the current directory. Call the Algol 68 compiler to
      translate the Algol 68 source to C. The C file will be in the
      current directory. The C program will be compiled by 'gcc' into
      an object module (ending with '.o') in the current directory.
      This object module will then be linked with the following
      libraries:
      <ul>
         <li>liba68s.a: the QAD standard prelude</li>
         <li>liba68.a: the run-time Algol 68 library</li>
         <li>libm.so: the mathematical library</li>
         <li>libc.so: the C library</li>
      </ul>The resulting binary program will be in the current
      directory.</dd>
   <dt>ca -m mod decs.w68</dt>
   <dd>Preprocess the DECS module to produce decs.a68. Translate the
      Algol 68 to C, emitting a module information file 'decs.m'.
      Compile the output C (in 'decs.c') producing the file 'decs.o'.
      Create, or insert, the '.o' file into the static library
      'libmod.a' in the $HOME/lib<!--$--> directory. Store the '.m' file in
      the directory $HOME/lib/m.<!--$--></dd>
   <dt>ca -l mod -l forms prog.w68</dt>
   <dd>Preprocess 'prog.w68' with 'tang' to produce 'prog.a68'.
      Translate this file using 'a68toc' producing 'prog.c'. Compile
      the C file using 'gcc' into 'prog.o'. Link 'prog.o' with
      precompiled modules in $HOME/lib/libmod.a<!--$--> and also link the
      libraries 'libforms.so', 'liba68s.a', 'liba68.a', 'libm' and
      'libc' to produce the binary program 'prog' in the current
      directory.</dd>
   <dt>ca -m mod -D module</dt>
   <dd>Delete module from static library ~/lib/libmod.a and its
   .m file from the m directory.</dd>
</dl>

@ 'tang' can take the following switches (the switches '-h' and '-v'
are omitted from this list):
<dl>
   <dt>-d</dt>
   <dd>Switch on debugging. Output wil be to 'tang.dbg' in the current
      directory.</dd>

   <dt>-V</dt>
   <dd>Ensure that tang does not emit comments to the output Algol 68
      program source.</dd>

   <dt>-wdirectory</dt>
   <dd>Supply a directory to 'tang' for finding included files. The
      directory is part of the '-w' argument.</dd>
</dl>
The arguments for 'tang' are kept in this string.

@<Names...@>=
STRING @!tang args;

@ 'a68toc' can take the following switches (many are omitted because
they are not useful for compilation):
<dl>
   <dt>-cdir</dt>
   <dd>Specifies a directory to be added to the list of directories
      where '.c' files, produced in previous compilations, can be used
      to get a unique seed (see '-uname' below). Optional.</dd>

   <dt>-check</dt>
   <dd>Use the compiler to check Algol 68 syntax only. No C file is
      produced, but a module information file will be produced if the
      module being checked is a 'DECS' module. Optional.</dd>

   <dt>-dir</dt>
   <dd>Specifies a directory to be added to the list of directories in
      which 'a68toc' will search for '.m' files of previously compiled
      modules. Where the Algol 68 module being compiled has a 'USE'
      clause, any modules used other than the standard prelude, will
      have a '.m' file stored in the 'm' subdirectory of any of these
      directories. The environment variable 'A68_DIR' contains a
      colon-separated list of the default directories. Mandatory.</dd>

   <dt>-lib</dt>
   <dd>Specifies the directory in which the '.m' file of the QAD
      standard prelude can be found. The environment variable
      'A68_LIB' contains the default value. Mandatory.</dd>

   <dt>-long (-l)</dt>
   <dd>Specifies that the compiler will recognise 'LONG LONG' modes.
      'ca' does not use this. Either this one or the next one is
      mandatory.</dd>

   <dt>-short (-s)</dt>
   <dd>Specifies that the compiler will recognise 'SHORT SHORT' modes.
       This is used by 'ca'. Either this one or the previous one is
       mandatory.</dd>

   <dt>-uname</dt>
   <dd>Specifies where the 'a68toc' compiler will find the seed
      required for constructing unique identifiers. The options which
      follow this switch are:
      <ul>
         <li>seedfile: look for the file named in the environment
            variable 'A68_NAMESEED'. It should be in the current
            directory.</li>
         <li>cfile: look for the seed in the '.c' file obtained in a
            previous compilation of the module being processed. The
            directories seached for the '.c' file are specified by the
            environment variable 'A68_CDIR' or by directories given by
            '-cdir' switches (each one followed by a directory name:
            see above).</li>
         <li>uname: this consists of 7 upper-case letters.</li>
      </ul><br />
      'ca' uses a default value of 'seedfile'. Mandatory.</dd>

   <dt>-verbose (-v)</dt>
   <dd>Causes generation of helpful comments in the generated C file.
      'ca' uses this option. Optional.</dd>
</dl><br />
The arguments for 'a68toc' are kept in this string.

@<Names...@>=
STRING @!a68toc args;

@ 'ca' uses the following switches:
<dl>
   <dt>-c</dt>
   <dd>Specifies that run-time checks should be switched off (NOT
      recommended).</dd>

   <dt>-C</dt>
   <dd>Its argument specifies a directory to search for C files in
      which a seed can be found (see -uname).</dd>

   <dt>-D</dt>
   <dd>Its argument specifies a module to be deleted from the static
      library in ~/lib by default. The library should be mentioned in
      the argument of a <b>-m</b> switch.</dd>

   <dt>-d</dt>
   <dd>Its argument specifies a directory to be added to the
      directories specified by the environment variable A68_DIR in
      which 'a68toc' will search for '.m' files of previously compiled
      modules.</dd>

   <dt>-f</dt>
   <dd>Its argument specifies a flag to be passed to 'gcc'.</dd>

   <dt>-g</dt>
   <dd>Switch on debugging. This affects 'tang' and 'gcc' only.</dd>

   <dt>-h</dt>
   <dd>Causes 'ca' to emit a useful help message.</dd>

   <dt>-i</dt>
   <dd>Its argument specifies a directory to be added to the include
      directories used by 'gcc'. The default directories are
      equivalent to '-i /usr/include/algol68 -i /usr/include'.</dd>

   <dt>-L</dt>
   <dd>Its argument specifies a directory to be searched for linking
      libraries. Its argument is added to the existing list. Its
      default value is $HOME/lib<!--$-->.</dd>

   <dt>-l</dt>
   <dd>Its argument specifes a library to be added to those searched
      for required modules. The default libraries are given by this
      string:<br />
      '-la68s -la68 -lm -lc'. They are always specified in the linking
      command.</dd>

   <dt>-M</dt>
   <dd>Its argument specifies a directory in which a static library, either to be
      created or to be added to, can be found. This switch is only
      useful when a 'DECS' modules is being compiled. The default
      value is $HOME/lib<!--$-->.</dd>

   <dt>-m</dt>
   <dd>Its argument specifies a static library to store the object module '.o' for
      future linking. If the library does not exist, it will be
      created. It has no default value.</dd>

   <dt>-s</dt>
   <dd>Specifies that 'a68toc' should perform syntax analysis of the
      input program only. No C file will be generated, but a '.m' file
      will be generated if the module being checked is a 'DECS'
      module.</dd>

   <dt>-u</dt>
   <dd>Its argument specifies the whereabouts or value of the unique seed required
      by 'a68toc'. Its argument can take the values specified above
      for 'a68toc'. It is unusual to specify the actual seed, since
      that can be used by all the programs in this directory.</dd>

   <dt>-V</dt>
   <dd>Specifies that 'tang' should not issue comments in the output
      Algol 68 program.</dd>

   <dt>-w</dt>
   <dd>Its argument specifies a directory to be added to the list of
      directories to be searched for Web 68 preludes. The default value
      of $HOME/lib<!--$--> is built-in to 'tang'.</dd>
</dl>

@ 'ca' will use the values in the following environment variables:
<dl>
   <dt>A68_DIR</dt>
   <dd>See the '-d' switch for 'ca' above.</dd>

   <dt>A68_LIB</dt>
   <dd>Specifies the directory containing the '.m' file for the
      standard prelude.</dd>

   <dt>A68_NAMESEED</dt>
   <dd>Specifes the name of the file containing the unique seed for
      'a68toc'. See the 'ca' switch '-u' above.</dd>
</dl>
Here is where the contents of these environment variables are kept.

@<Plain...@>=
[]CHAR
   @!env home=ENV "HOME",
   @!env a68lib=ENV "A68_LIB",
   @!env a68dir=ENV "A68_DIR",
   @!env a68nameseed=ENV "A68_NAMESEED",
   @!root = "/usr/share/algol68toc";

@ Some useful declarations.

@<Plain...@>=
CHAR @!colon = ":", @!dot = ".", @!vert = "|";
[]CHAR @!libk = "lib", @!typk = ".a";

@1Argument processing.
These names are used in argument processing.

@<Name...@>=
STRING
   @!gcc check:="-DA68_CHECK",
   @!a68dir,
   @!a68lib:="-lib "+env a68lib,
   @!a68toc check,
   @!cdirs:="-cdir .",
   @!cflags,
   @!include dirs,
   @!infn,
   @!libraries:="-L"+env home+"/lib",
   @!static lib,
   @!static lib dir:=env home+"/lib",
   @!tang flag,
   @!uname:="-uname seedfile",
   @!web dirs;

@ Initial values of some strings need to be assigned. !env a68dir!
might contain a colon-delimited list of directories.

@<Logic...@>=
IF char in string(colon,LOC INT,env a68dir)
THEN #use a memory file to extract the individual directories#
   FILE mf; STRING dir;
   open(mf,MAKERVC env a68dir+colon,mem channel);
   make term(mf,colon);
   on logical file end(mf,(REF FILE f)BOOL:
      (close(f); GOTO eomf; SKIP));
   DO
      get(mf,(dir,LOC CHAR));
      add to(a68dir,"-dir "+dir)
   OD;
eomf:
   SKIP
ELSE add to(a68dir,"-dir "+env a68dir)
FI;

@ !include dirs! needs to be set by default.

@<Logic...@>=
add to(include dirs,"-I/usr/include/algol68");
add to(include dirs,"-I/usr/include");

@2Program arguments.
The arguments are made available by opening the !arg channel!.

@<Logic...@>=
open(LOC FILE,"",arg channel);

@ !argc! contains a count of the number of arguments, while 'argv' can
be indexed to access each argument.

@<Logic...@>=
IF argc = 1
THEN usage
ELSE
   FOR a FROM 2 TO argc
   DO
      []CHAR arg=CSTRTORVC argv[a];
      IF "-" BEGINS arg
      THEN #this is a switch#
         IF UPB arg /= 2
         THEN message("argument ["+arg+"]",1) #unknown switch#
         ELIF char in string(arg[2],switch,"cghsV")
         THEN #these switches do not have an argument#
            CASE switch
            IN
            #c# gcc check:=""
               ,
            #g#(
                  debug:=TRUE;
                  add to(libraries,"-lg");
                  add to(cflags,"-g");
                  add to(tang flag,"-d")
               )
               ,
            #h#usage
               ,
            #s#a68toc check:="-check"
               ,
            #V#add to(tang flag,"-V")
            ESAC;
            switch:=0
         ELIF char in string(arg[2],switch,"CDdfiLlMmuw")
         THEN SKIP #!switch! has been set#
         ELSE message(arg,1)
         FI
      ELIF switch = 0
      THEN infn:=arg
      ELSE
         CASE switch
         IN
         #C#add to(cdirs,"-cdir "+arg)
            ,
         #D#@<Delete !arg! from the current static library@>
            ,
         #d#add to(a68dir,"-dir "+arg)
            ,
         #f#add to(cflags,arg)
            ,
         #i#add to(include dirs,"-I"+arg)
            ,
         #L#add to(libraries,"-L"+arg)
            ,
         #l#add to(libraries,"-l"+do lib(arg))
            ,
         #M#static lib dir:=arg
            ,
         #m#static lib:=do lib(arg) #full name = libk+static lib+typk#
            ,
         #u#IF arg = "cfile"
            THEN uname:="-uname cfile"
            ELIF arg/="seedfile" & UPB arg = 7
            THEN uname:="-uname "+UC arg
            FI
            ,
         #w#add to(web dirs,"-w"+arg)
         ESAC;
         switch:=0
      FI
   OD
FI;

@ Here is !switch! and !debug!.

@<Names...@>=
INT @!switch:=0;
BOOL @!debug:=FALSE;

@2Procedures used in argument processing.
This procedure is used to add values to strings.

@<Proced...@>=
PROC @!add to = (REF STRING @!which,STRING @!value)VOID:
IF which = ""
THEN which:=value
ELSE which+:=blank+value
FI; #add to#

@ This procedure investigates a library argument, removing "lib" from
the front and ".a" or ".so" from the end.

@<Proced...@>=
PROC @!do lib = ([]CHAR @!str)[]CHAR:
BEGIN
   STRING lib;
   IF libk BEGINS str
   THEN lib:=str[1+UPB libk:]
   ELSE lib:=str
   FI;
   lib:=lib UPTO dot
END; #do lib#

@ Here is the usage procedure. It prints a useful message and then
ends the program.

@<Proced...@>=
PROC @!usage = VOID:
BEGIN
   print((
      "Usage: ca [-c][-C cdir][-D module][-d m-dir][-f gcc-flag][-g]",newline,
      "          [-h][-i inc-dir][-L link-dir][-l lib][-M mod-dir]",newline,
      "          [-m lib][-s][-u seed][-V][-w tang-dir] module-path",newline,
      newline,
      " -c       No run-time checking (not recommended).",newline,
      " -C dir   Directory to search for C files for a unique seed.",newline,
      " -D module",newline,
      "          Delete this module from the static library specified as the",newline,
      "            argument of a -m switch.",newline,
      " -d m-dir Add 'm-dir' to the list of directories containing '.m' files.",
      newline,
      "            in fact, a subdirectory called 'm' will be searched.",newline,
      " -f gcc-flag",newline,
      "          Specifies a flag to be passed to gcc.",newline,
      " -g       Switch on debugging. This affects 'tang' and 'gcc'.",newline,
      " -h       Print this message.",newline,
      " -i inc-dir",newline,
      "          The 'inc-dir' will be added to the include directories",newline,
      "            to be searched by 'gcc' for C header files.",newline,
      " -L link-dir",newline,
      "          Specifies a directory to be searched for libraries for linking.",
      newline,
      " -l lib   Specifies a library for linking.",newline,
      " -M mod-dir",newline,
      "          Specifies a directory in which a static module library is kept.",
      newline,
      " -m lib   Specifies the name of a library in which DECS modules can be",newline,
      "            stored.",newline,
      " -s       Specifies that the module's syntax should be checked only.",newline,
      "            No C file will be produced, but a '.m' file will be.",newline,
      " -u seed  'seed' can have theses values:",newline,
      "            seedfile (the default)",newline,
      "                     the file specified by the environment variable",newline,
      "                     A68_NAMESEED will be used for the seed.",newline,
      "            cfile    see switch -C. The C file should have the same name as",
      newline,
      "                     the module being compiled.",newline,
      "            7 upper-case letters",newline,
      "                     they will be used as the first unique seed.",newline,
      " -V       Specifies that 'tang' should not emit comments to its output.",
      newline,
      " -w tang-dir",newline,
      "          Specifies a directory for 'tang' to search for included",newline,
      "            Web 68 preludes.",newline,newline,
      "Defaults:",newline,
      "gcc check" P gcc check,newline,
      "          Use -c to change this.",newline,
      "a68dir" P a68dir,newline,
      "          Use -d to add to this.",newline,
      "a68toc check" P a68toc check,newline,
      "          Use -s to change this.",newline,
      "cdirs" P cdirs,newline,
      "          Use -C to add to this.",newline,
      "cflags" P cflags,newline,
      "          Use -f to add to this.",newline,
      "include dirs" P include dirs,newline,
      "          Use -i to add to this.",newline,
      "libraries" P libraries,newline,
      "          Use -L and -l to add to this.",newline,
      "static lib" P static lib,newline,
      "          Use -m to replace this.",newline,
      "static lib dir" P static lib dir,newline,
      "          Use -M to replace this.",newline,
      "tang flag" P tang flag,newline,
      "          Use -V or -g to add to this.",newline,
      "uname" P uname,newline,
      "          Use -u to replace this.",newline,
      "web dirs" P web dirs,newline,
      "          Use -w to add to this.",newline,
      newline));
   exit(1)
END; #usage#

@ This procedure indexes !messages! to print a message to the console
and end the program.

@<Proced...@>=
PROC @!message = ([]CHAR s,INT m)VOID:
BEGIN
   print(("ca: ",s," error: ",messages[m],newline));
   exit(1)
END; #message#

@ The messages are kept in !messages!.

@<Plain...@>=
[][]CHAR @!messages = [][]CHAR (
   "unknown switch",
   "'posix wait pid' did not yield the process id of 'tang'",
   "child did not exit normally",
   "fork exec failed",
#5#"mkdir failed",
   "mv of .m file failed",
   "create pipe failure",
   "fork failure",
   "execvp failure for 'rs'",
#10#"'ar' errors",
   "'rm' error'"
);   

@ This operator is used to provide string values.

@<Oper...@>=
OP @!P = (STRING @!id,@!val)[]CHAR: id+"="""+val+"""";

@1Running the child processes.
Firstly, check the subvalue of !infn! to see whether it is a Web 68
file (shown by its extension).

@<Logic...@>=
IF (infn AFTER dot) = "w68"
THEN @<Construct the 'tang' command line and launch 'tang'@>
FI;

@2Running 'tang'.
All the necessary strings to construct the arguments of 'tang' are
in the top-level strings.

@<Construct the 'tang'...@>=
tang args:="tang|" +
   (tang flag/=""|replace(tang flag,blank,vert)+vert|"") +
   (web dirs/=""|replace(web dirs,blank,vert)+vert|"") +
   infn;

@ Now fork and execute a child process.

@<Construct the 'tang'...@>=
IF (child res:=run child("tang",tang args))/=0
THEN exit(child res) #tang found errors#
FI

@ There now exists an Algol 68 file, so construct its identification
plus those of the C file, the object file and the binary program.

@<Logic...@>=
binary:=infn UPTO dot;
a68fn:=binary+".a68";
cfn:=binary+".c";
objfn:=binary+".o";

@2Running 'a68toc'.
Now call 'a68toc' to translate the Algol 68 program to C.

@<Logic...@>=
@<Construct the 'a68toc' argument string@>
IF (child res:=run child("a68toc",a68toc args)) /= 0
THEN exit(child res) #'a68toc' found errors#
ELIF a68toc check /= ""
THEN #No C file created by 'a68toc'#
   stop
ELIF @<Construct the 'gcc' argument string@>
   (child res:=run child("gcc",gcc args)) /= 0
THEN exit(child res) #'gcc' compilation errors#
ELIF @<Check whether the module is a program@>
THEN #It is#
   @<Construct the linking argument for 'gcc'@>
   IF (child res:=run child("gcc",gcc args))/=0
   THEN exit(child res) #linking errors#
   ELSE stop #program compiled: binary exists, so end#
   FI
ELIF @<Check to see if the static library directory exists@>
THEN #It does not exist#
   @<Create the static library directory@>
FI;

@ The 'a68toc' argument string is somewhat involved.

@<Construct the 'a68toc'...@>=
a68toc args:="a68toc|-s|" +
   (a68toc check/=""|a68toc check+vert|"") +
   (a68lib/=""|replace(a68lib,blank,vert)+vert|"") +
   (a68dir/=""|replace(a68dir,blank,vert)+vert|"") +
   (uname/=""|replace(uname,blank,vert)+vert|"") +
   a68fn;

@2Running 'gcc'.
Arguments to 'gcc' are often very long and involved, but we use a
simple interface. Only one -D argument and no options.

@<Construct the 'gcc'...@>=
gcc args:="gcc|-O0|" +
   (gcc check/=""|gcc check+vert|"") +
   (cflags/=""|replace(cflags,blank,vert)+vert|"") +
   (include dirs/=""|replace(include dirs,blank,vert) + vert|"") +
   "-o|"+objfn+vert+"-c"+vert+cfn;

@ @<Logic...@>=
@<Construct the 'ar' add argument@>
IF (child res:=run child("ar",ar args))/=0
THEN #'ar' errors#
   exit(child res)
ELIF @<Construct the 'ranlib' arguments@>
   (child res:=run child("ranlib",ranlib args))/=0
THEN exit(child res) #ranlib errors#
ELIF
   print(("ca: contents of ",static lib dir,"/",libk+static lib+typk,newline));
   (child res:=
      run child("ar",
                "ar|tv|"+static lib dir+"/"+libk+static lib+typk))/=0
THEN exit(child res) #ar errors#
ELSE
   @<Check to see if the 'm' directory exists and create it if necessary@>
   @<Move the '.m' file to the 'm' directory@>
FI

@ The module is only linked if it is a program, so run 'rs' to search
for "PROGRAM". If it is found, 'rs' will exit with zero status.
Because 'rs' emits matched lines to !stand out!, it has to be launched
as a piped child. Its output can then be read and ignored.

@<Check whether the module...@>=
CHILDPIPE @!rs pipe:=exec piped child("rs","rs|PROGRAM|"+a68fn);
child res:=
CASE pid OF rs pipe +3
IN
#-2#   (message("",7); SKIP)
      ,
#-1#   (message("",8); SKIP)
      ,
# 0#   (message("",9); SKIP)
OUT
   INT @!status;
   on logical file end(r OF rs pipe,(REF FILE f)BOOL:
      (GOTO eopipe; SKIP));
   DO
      get(r OF rs pipe,(LOC STRING,newline))
   OD;
eopipe:
   close(r OF rs pipe);
   IF posix wait pid(pid OF rs pipe,status,2r0) /= pid OF rs pipe
   THEN message("",2); SKIP
   ELIF w if exited(status)
   THEN w exit status(status)
   ELSE message("",3); SKIP
   FI
ESAC;
close(w OF rs pipe);
close(e OF rs pipe);
child res = 0

@2Running 'gcc' to link the program.

@<Construct the linking...@>=
gcc args:="gcc|-o|" + binary + vert + root + "/Afirst.o|" + objfn + vert +
   (libraries/=""|replace(libraries,blank,vert)+vert|"") +
   "-la68s|-la68|-lm|-lc";

@2The static library.
When the module being compiled is a 'DECS' module, it needs to be put
into a static library. The directory of that library is the subvalue
of !static lib dir! and the library name is !libk+static lib+typk!.
Check to see whether the directory exists. If not, create it. 'ar'
will create the library if needed.

@<Check to see if the static...@>=
static lib dir:=NORM static lib dir;
(rs:=stat(static lib dir)) IS no stat

@ Now create the static library directory.

@<Create the static...@>=
IF mkdir(static lib dir,8r755)/=0
THEN message("",5)
FI

@2Running 'ar'.
Run 'ar' to add the object module ('.o') to the static library.

@<Construct the 'ar'...@>=
ar args:="ar|rv|"+static lib dir+"/"+libk+static lib+typk+vert+objfn;

@ This code deletes the module named by !arg! from the module library
specified by !static lib! which is in !static lib dir!. Firstly, check
whether arg ends in '.o' and add it if not.

@<Delete...@>=
IF STRING
      @!module:=(".o" ENDS arg|arg|arg+".o"),
      @!statlib:=libk+static lib+typk;
   
   (child res:=run child("ar","ar|dv|"+
                         static lib dir+"/"+statlib+"|"+module))/=0
THEN message("",10)
ELIF
   (child res:=
      run child("rm","rm|-fv|"+
                static lib dir+"/m/"+(module UPTO dot)+".m"))/=0
THEN message("",11)
ELIF
   print(("ca: contents of ",static lib dir,"/",statlib,newline));
   (child res:=
      run child("ar",
                "ar|tv|"+static lib dir+"/"+statlib))/=0
THEN message("",10)
ELSE print(("ca: module ",module," deleted from ",libk+static lib+typk,newline));
   stop
FI

@2Running 'ranlib'.
Run 'ranlib' to ensure random access to the static library is
possible.

@<Construct the 'ranlib'...@>=
ranlib args:="ranlib|"+static lib dir+"/"+libk+static lib+typk;

@2Moving the '.m' file.
Any '.m. files created by 'a68toc' need to be put in a subdirectory
called 'm' of the directory containing the static library. Thus, in
'static lib dir'+"/m". Before moving the file, check to see whether the
'm' directory exists and create it if it doesn't.

@<Check to see if the 'm'...@>=
IF m dir:=static lib dir+"/m";
   (rs:=stat(m dir)) IS no stat
THEN #it doesn't exist, so create it#
   IF mkdir(m dir,8r755)/=0
   THEN message("",5)
   FI
FI;

@ Now use 'mv' to move the '.m' file to the m-directory.

@<Move the '.m'...@>=
IF (child res:=run child("mv","mv|"+binary+".m|"+m dir))/=0
THEN message("",6)
ELSE print(("ca: .m file moved to ",static lib dir,"/m",newline))
FI

@ This procedure encapsulates all the low-level process handling. The
yield is the exit value of the child.

@<Proced...@>=
PROC @!run child = ([]CHAR @!prog,@!args)INT:
IF INT
      @!child process id:=fork exec(prog,args),
      @!child status;
   child process id <= 0
THEN message("",4); SKIP # fork exec failed#
ELIF posix wait pid(child process id,child status,2r0) /= child process id
THEN message("",2); SKIP #'posix wait pid' did not yield...#
ELIF w if exited(child status)
THEN w exit status(child status)
ELSE message("",3); SKIP #child not exited normally#
FI;

@ @<Names...@>=
INT @!child res;
STRING
   @!a68fn,
   @!ar args,
   @!binary,
   @!cfn,
   @!gcc args,
   @!m dir,
   @!objfn,
   @!ranlib args;
REF STAT @!rs;

@1Calls to declarative macros.
They are all here.

@<Include...@>=
macro gp op after;
macro gp op begins char;
macro gp op begins row char;
macro gp op ends row char;
macro gp op uc row char;
macro gp op upto;
macro gp replace;
macro sys exec piped child;
macro sys fork exec;
macro sys mkdir;
macro sys op norm;
macro sys posix wait pid;
macro sys stat;

@1System dependencies.
Check these if you are porting this program to another platform.

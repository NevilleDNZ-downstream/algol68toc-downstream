@1Introduction.
This prelude provides a mode and operators for expressing ranges of
characters in the ISO10646 Universal Character Set. It is intended to
be used for !USTRING! regular expressions.

This message should reflect the current version.

@m cvs ucharbag = "$Id: ucharbag.w,v 1.1 2003/12/26 16:35:52 sian Exp $"

@aDECS ucharbag CONTEXT VOID
USE unicode,standard:
@<CModes at the top level@>
@<COther values at the top level@>
@<COperators at the top level@>
SKIP
KEEP
@<Public tags@>
FINISH

@ A !CHUNK! has a beginning !UCHAR! and an end !UCHAR!.

@<CModes...@>=
MODE CHUNK = STRUCT(UCHAR b,e);
MODE CHARBAG = REF[]CHUNK;

@ @<Public...@>=
 CHUNK, CHARBAG

@ A number of basic operators are required for manipulating !CHUNK!s and
!CHARBAG!s.  All these operators presume that the chunks are distinct. They are
used in the operator !OR! defined below. Firstly, here is how to go from a
!CHUNK! to a !CHARBAG!.

@<COper...@>=
OP C = (CHUNK ck)CHARBAG:
(
	HEAP[1]CHUNK hk;
	hk[1]:=ck;
	hk
);

@ @<Public...@>=
 ,C(CHUNK)

@ Define basic addition of two !CHUNK!s to give a !CHARBAG!.

@<COper...@>=
OP + = (CHUNK a,b)CHARBAG:  HEAP[2]CHUNK:=(a,b);

@ @<Public...@>=
 ,+(CHUNK,CHUNK)

@ Now give the addition operators for those cases when one of the
operands already has mode !CHARBAG!. Note that this form of addition is
not commutative, so we have to give two different definitions.

@<COper...@>=
OP + = (CHARBAG a,CHUNK b)CHARBAG:
(
   HEAP[UPB a[:]+1]CHUNK c;
   c[:UPB a[:]]:=a;  c[UPB c]:=b;
   c
); #+#

@ @<Public...@>=
 ,+(CHARBAG,CHUNK)

@ !+! with the operands reversed. Clearly, the order of the chunks
in the charbag is significant.

@<COper...@>=
OP + = (CHUNK a,CHARBAG b)CHARBAG:
(
   HEAP[1+UPB b[:]]CHUNK c;
   c[1]:=a;  c[2:]:=b;
   c
); #+#

@ @<Public...@>=
 ,+(CHUNK,CHARBAG)

@ Now define addition for two operands of mode !CHARBAG!.

@<COper...@>=
OP + = (CHARBAG a,b)CHARBAG:
(
   HEAP[UPB a[:]+UPB b[:]]CHUNK c;
   c[:UPB a[:]]:=a;  c[1+UPB a[:]:]:=b;
   c
); #+#

@ @<Public...@>=
 ,+(CHARBAG,CHARBAG)

@ Here is equality defined for two chunks.

@<COper...@>=
OP = = (CHUNK c1,c2)BOOL: b OF c1 = b OF c2 & e OF c1 = e OF c2;

@ @<Public...@>=
 ,=(CHUNK,CHUNK)

@ Lastly, of the basic operators, here is an operator which enables us
to test whether a !UCHAR! is in a !CHARBAG!.

@<COper...@>=
OP ELEM = (UCHAR c,CHARBAG bag)BOOL:
IF INT j:=LWB bag-1;
   UPB bag < LWB bag
THEN FALSE
ELIF
   FOR i FROM LWB bag TO UPB bag
   WHILE
      c>=b OF bag[i]
   DO
      j:=i
   OD;
   j<LWB bag
THEN FALSE
ELSE c<=e OF bag[j]
FI; #ELEM(UCHAR,CHARBAG)#

@ @<Public...@>=
 ,ELEM(UCHAR,CHARBAG)

@ In the operator !OR!, we need to have a flexible row of !CHUNK!, but of course,
the !+! operator is not declared for such a mode. This operator takes a value
of such a mode and yields a CHARBAG which can figure as the operand of !+!. We
shall need another operator to convert the !CHARBAG! to a !REF FLEX[]CHUNK!
again. Because these operators are only used in this module, they are not
made public.

@<COper...@>=
OP FC = (REF FLEX[]CHUNK rfc)CHARBAG:
(
	HEAP[LWB rfc:UPB rfc]CHUNK ck;
	FOR i FROM LWB rfc TO UPB rfc
	DO
		ck[i]:=rfc[i]
	OD;
	ck
);

@ @<COper...@>=
OP CF = (CHARBAG cb)REF FLEX[]CHUNK:
(
	HEAP FLEX[LWB cb:UPB cb]CHUNK hfk;
	FOR i FROM LWB cb TO UPB cb
	DO
		hfk[i]:=cb[i]
	OD;
	hfk
);

@ This operator combines !CHARBAG a! with !CHARBAG b!. In a sense, it
normalises two !CHARBAG!s and therefore could be used to normalise one
with the formula !a OR a!.

We need to compare each !CHUNK! of <i>b</i> with <i>a</i>, so we iterate over
all the chunks of <i>b</i>.

Then, we need to determine the position of the end-points of each chunk of
<i>b</i> relative to the chunks of <i>a</i>. We shall use the following
nomenclature:-

<dl>
<dt><i>b<sub>i</sub></i></dt>
<dd>the chunk in <i>b</i> under consideration</dd>
<dt><i>b<sup>b</sup><sub>i</sub></i></dt>
<dd>the beginning of <i>b<sub>i</sub></i></dd>
<dt><i>b<sup>e</sup><sub>i</sub></i></dt>
<dd>the end of <i>b<sub>i</sub></i></dd>
<dt><i>a<sub>j</sub></i></dt>
<dd>the chunk in <i>a</i> nearest to <i>b<sup>b</sup><sub>i</sub></i> or
    <i>b<sup>e</sup><sub>i</sub></i></dd>
</dl>
We note that
<pre>
r<sup>b</sup> = <i>b</i> <b>of</b> <i>r</i>
r<sup>e</sup> = <i>e</i> <b>of</b> <i>r</i>
</pre>

@<COper...@>=
OP OR = (CHARBAG bag a,bag b)CHARBAG:
IF UPB bag a < LWB bag a
THEN bag b #!bag a = null bag!#
ELIF UPB bag b < LWB bag b
THEN bag a #!bag b = null bag!#
ELSE
   HEAP FLEX[1:0]CHUNK bag c:=bag a;
   FOR i FROM LWB bag b TO UPB bag b
   DO
      CHUNK bi=bag b[i];
      @<Determine the end-points of !bi!@>
      @<Continuation of !OR!@>
FI;

@ Here, get the indices of <i>bag a</i> which identify chunks of
<i>bag a</i> related to the end-points of <i>bag b<sub>i</sub></i> and
define appropriate synonyms for them.

@<Determine the end-points...@>=
INT s:=LWB bag c-1, f:=LWB bag c-1;  #indices into <i>bag a</i>#
UCHAR b bi=b OF bi, e bi=e OF bi;    #end-points#
FOR j FROM LWB bag c TO UPB bag c WHILE b bi>=b OF bag c[j]
DO
   s:=j
OD;

FOR j FROM LWB bag c TO UPB bag c WHILE e bi>=b OF bag c[j]
DO
   f:=j
OD;

@ Each end of <i>b<sub>i</sub></i> can be either within or outwith
a chunk of <i>bag c</i>. If outwith, there are three possibilities:-
<ol>
<li>Before the first chunk of <i>bag c</i></li>
<li>Between two chunks of <i>bag c</i></li>
<li>After the last chunk of <i>bag c</i></li>
</ol>
This gives four possibilities for the beginning of a chunk, but because
the condition <i>bag b<sup>b</sup><sub>i</sub> &le;
bag b<sup>e</sup><sub>i</sub></i> holds, there are less than the maximum
of sixteen cases for both end-points. The result of each case will be
assigned to <i>bag c</i>.

@<Continuation...@>=
bag c:=

@ (1) <i>bag b<sup>b</sup><sub>i</sub>&lt;bag c<sup>b</sup><sub>1</sub>
&nbsp;&rarr;</i> the beginning of <i>bag b<sub>i</sub></i> starts before
the first chunk of <i>bag c</i>. There are four sub-cases:-
<dl>
<dt>(1.1)</dt>
<dd><i>bag b<sup>e</sup><sub>i</sub>&lt;bag c<sup>b</sup><sub>1</sub></i><br />
There is no overlap so that <i>bag b<sub>i</sub></i> is a new chunk for
<i>c</i>.</dd>
<dt>(1.2)</dt>
<dd><i>bag c<sup>e</sup><sub>f</sub>&lt;bag b<sup>e</sup><sub>i</sub></i><br />
<i>bag b<sub>i</sub></i> completely overlaps chunks
<i>bag c<sub>k</sub>:&nbsp;k&isin;[1,f]</i> so that the
<i>bag c<sub>k</sub></i> are replaced by <i>bag b<sub>i</sub></i>.</dd>
<dt>(1.3)</dt>
<dd><i>bag b<sup>e</sup><sub>i</sub> &le; bag c<sup>e</sup><sub>f</sub></i>
<br />
The end of <i>bag c<sub>f</sub></i> overlaps the end of
<i>bag b<sub>i</sub></i> so that chunks
<i>bag c<sub>k</sub>:&nbsp;k&isin;[1,f]</i> are replaced by
<i>bag b<sub>i</sub></i>, but the new chunk extends to
<i>bag c<sup>e</sup><sub>f</sub></i>.</dd>
<dt>(1.4)</dt>
<dd><i>bag b<sup>e</sup><sub>i</sub>&gt;bag c<sup>e</sup><sub>l</sub></i><br />
<i>bag b<sub>i</sub></i> completely overlaps <i>bag c</i> so that
<i>bag c</i> is replaced by <i>bag b<sub>i</sub></i>.</dd>
</dl>

@<Continuation...@>=
IF s < LWB bag c
THEN #case 1#
   IF e bi < b OF bag c[LWB bag c]
   THEN CF(C bi+FC bag c)               #case 1.1#
   ELIF CHUNK cf=bag c[f]; e OF cf<e bi
   THEN CF(C bi+bag c[f+1:])         #case 1.2#
   ELIF e bi > e OF bag c[UPB bag c]
   THEN CF C bi #case 1.4#
   ELSE CF C CHUNK(b bi,e OF cf)  #case 1.3#
   FI

@ (2) <i>bag b<sup>b</sup><sub>i</sub>&le;
bag c<sup>e</sup><sub>s</sub>&nbsp;&rarr;</i> the beginning of
<i>bag b<sub>i</sub></i> lies within <i>bag c<sub>s</sub></i>.
There are two sub-cases:-
<dl>
<dt>(2.1)</dt>
<dd><i>bag b<sup>e</sup><sub>i</sub>&le; bag c<sup>e</sup><sub>f</sub></i><br />
The beginning of <i>bag c<sub>s</sub></i> overlaps the beginning of
<i>bag b<sub>i</sub></i> and the end of
<i>bag c<sub>f</sub></i> overlaps the end of <i>bag b<sub>i</sub></i>.
Thus the chunks <i>bag c<sub>k</sub>:&nbsp;k&isin;[s,f]</i> are
replaced by a single chunk beginning at <i>bag c<sup>b</sup><sub>s</sub></i>
and ending at <i>bag c<sup>e</sup><sub>f</sub></i>.</dd>
<dt>(2.2)</dt>
<dd><i>bag c<sup>e</sup><sub>f</sub>&lt;bag b<sup>e</sup><sub>i</sub></i><br />
the beginning of <i>bag c<sub>s</sub></i> overlaps the beginning of
<i>bag b<sub>i</sub></i>, but the end of
<i>bag b<sub>i</sub></i> overlaps the end of <i>bag c<sub>f</sub></i>.
Thus the chunks <i>bag c<sub>k</sub>:&nbsp;k&isin;[s,f]</i> are
replaced by a single chunk beginning at <i>bag c<sup>b</sup><sub>s</sub></i>
and ending at <i>bag b<sup>e</sup><sub>i</sub></i>.</dd>
</dl>

@<Continuation...@>=
ELIF CHUNK cs=bag c[s]; b bi<=e OF cs
THEN
   IF CHUNK cf=bag c[f]; e bi<=e OF cf
   THEN CF(bag c[:s-1]+ C CHUNK(b OF cs,e OF cf)+bag c[f+1:]) #case 2.1#
   ELSE CF(bag c[:s-1]+C CHUNK(b OF cs,e bi)+bag c[f+1:])    #case 2.2#
   FI

@ (3) <i>bag c<sup>e</sup><sub>s</sub>&lt;bag b<sup>b</sup><sub>i</sub>&nbsp;
&rarr;</i> the beginning of <i>bag b<sub>i</sub></i> lies
beyond the end of <i>bag c<sub>s</sub></i>. Again, there are two sub-cases:-
<dl>
<dt>(3.1)</dt>
<dd><i>bag b<sup>e</sup><sub>i</sub> &le; bag c<sup>e</sup><sub>f</sub></i><br />
The end of <i>bag b<sub>i</sub></i> is overlapped by <i>bag c<sub>f</sub></i>
so that the chunks
<i>bag c<sub>k</sub>:&nbsp;k&isin;[s+1,f]</i> are replaced by a chunk which
starts at <i>bag b<sup>b</sup><sub>i</sub></i> and
ends at <i>bag c<sup>e</sup><sub>f</sub></i>.</dd>
<dt>(3.2)</dt>
<dd><i>bag c<sup>e</sup><sub>f</sub>&lt;bag b<sup>e</sup><sub>i</sub></i><br />
<i>bag b<sub>i</sub></i> completely overlaps the chunks
<i>bag c<sub>k</sub>:&nbsp;k&isin;[s+1,f]</i> which are thus
replaced by <i>bag b<sub>i</sub></i>.</dd>
</dl>

@<Continuation...@>=
ELIF e OF cs<b bi
THEN
   IF CHUNK cf=bag c[f]; e bi<=e OF cf
   THEN CF(bag c[:s]+C CHUNK(b bi,e OF cf)+bag c[f+1:]) #case 3.1#
   ELSE CF(bag c[:s]+C bi+bag c[f+1:])                  #case 3.2#
   FI

@ (4) <i>bag c<sup>e</sup><sub>l</sub>&lt;bag b<sup>b</sup><sub>i</sub>
&nbsp;&rarr;</i> the beginning of <i>bag b<sub>i</sub></i> lies beyond the
last chunk of <i>bag c</i> so that <i>bag b<sub>i</sub></i> is a new chunk
at the end of <i>bag c</i>.

@<Continuation...@>=
   ELSE CF(FC bag c+ C bi)
   FI
OD;
FC bag c

@ @<Public...@>=
 ,OR(CHARBAG,CHARBAG)

@ Here is the !NOT! operator for a !CHARBAG!.

@<COper...@>=
OP NOT = (CHARBAG bag)CHARBAG:
IF HEAP[LWB bag:UPB bag+1]CHUNK hb;
   hb[LWB hb]:=
      (U 2r0,
       U BIN(ABS bits OF b OF bag[LWB bag]-1));
   FOR i FROM LWB bag TO UPB bag-1
   DO
      hb[i+1]:=
         (U BIN(ABS bits OF e OF bag[i]+1),
          U BIN(ABS bits OF b OF bag[i+1]-1))
   OD;
   e OF bag[UPB bag]/=U BIN max int
THEN hb[UPB hb]:=
   (U BIN(ABS bits OF e OF bag[UPB bag]+1),
    U BIN maxint);
   hb
ELSE hb[:UPB bag]
FI; #NOT#

@ @<Public...@>=
 ,NOT(CHARBAG)

@ Lastly, here is !null bag!.

@<COther...@>=
CHARBAG null bag = HEAP[0]CHUNK;

@ @<Public...@>=
,null bag

@2System dependencies.
None.

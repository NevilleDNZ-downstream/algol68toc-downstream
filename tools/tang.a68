#1.1.1.2:# #1.1.1.3:# PROGRAM tang CONTEXT VOID USE standard#:1.1.1.3# BEGIN#
9.1.1.1:# OP ENV =([]CHAR en)[]CHAR:IF FILE ef;open(ef,en,envchannel)/=0 THEN
 put(standerr,( "ENV: cannot open ef with en=[",en, "]",newline)); ""ELSE STRING
 y;onlogicalfileend(ef,(REF FILE f)BOOL:(GOTO eof;SKIP));maketerm(ef,nulch);get(
ef,y);eof:close(ef);y FI;OP TC =(STRING s)STRING:IF s = ""THEN s ELIF s[LWB s]/=
 "~"THEN s ELIF[]CHAR home =ENV "HOME";s = "~"THEN home ELSE home+s[LWB s+1 :]FI
;PRIO UPTO =5 ;OP UPTO =([]CHAR s,CHAR t)[]CHAR:IF s = ""THEN ""ELIF INT toix;
charinstring(t,toix,s)THEN s[:toix-1 @LWB s]ELSE s FI;PROC getcwd =STRING:BEGIN
 PROC(VECTOR[]CHAR)CSTR posixgetcwd =ALIEN "GETCWD" "#define GETCWD(buf) \" 
" (void *)getcwd(A_VC_charptr(buf),A_INT_int(buf.upb))";RVC rvc:=HEAP VECTOR[
256 ]CHAR;INT p;WHILE(posixgetcwd(rvc)IS NIL|errno =34 |FALSE)DO rvc:=HEAP
 VECTOR[UPB rvc*2 ]CHAR OD;rvc UPTO nulch END; SKIP;OP REVERSE =([]CHAR s)[]CHAR
:IF s = ""THEN ""ELSE[LWB s:UPB s]CHAR ss;FOR i FROM UPB s BY---1 TO LWB s DO ss
[LWB s+UPB s-i]:=s[i]OD;ss FI;PRIO AFTER =6 ;OP AFTER =([]CHAR s,CHAR t)[]CHAR:
IF INT toix;charinstring(t,toix,s)THEN IF toix =UPB s THEN ""ELSE s[toix+1 :@
toix+1 ]FI ELSE ""FI;PRIO LOP =7 ;OP LOP =([]CHAR s,CHAR c)[]CHAR:REVERSE(
REVERSE s AFTER c);PRIO BEGINS =4 ;OP BEGINS =(CHAR c,[]CHAR s)BOOL:c =s[LWB s];
PRIO ENDS =4 ;OP ENDS =(CHAR c,[]CHAR s)BOOL:c =s[UPB s];PRIO FIND =6 ;OP FIND =
(CHAR c,[]CHAR s)INT:(INT p;charinstring(c,p,s)|p|LWB s-1 );OP FIND =([]CHAR a,b
)INT:IF a = ""THEN LWB b ELIF b = ""THEN LWB b-1 ELIF INT st1 =a[LWB a]FIND b;
st1<LWB b THEN st1 ELIF st1+UPB a-LWB a<=UPB b THEN IF a =b[st1:st1+UPB a-LWB a]
THEN st1 ELIF INT st2 =a FIND b[st1+1 :@st1+1 ];st2 =st1 THEN LWB b-1 ELSE st2
 FI ELSE LWB b-1 FI;PROC replace =([]CHAR s,x,y)[]CHAR:([LWB s:UPB s]CHAR ss;FOR
 n FROM LWB s TO UPB s DO ss[n]:=(INT ix:=LWB s-1 ;charinstring(s[n],ix,x)|y[ix]
|s[n])OD;ss);OP NORM =([]CHAR s)[]CHAR:IF STRING ss:=s[@1 ];[]CHAR cwd =getcwd,
ds = "./",sd = "/.",dds = "../",sdd = "/..";INT p:=0 ;CHAR dot = ".",stroke = 
"/",tilde = "~",flagdot =REPR 1 ;ss = ""THEN cwd ELSE IF tilde BEGINS ss THEN ss
:=TC ss FI;WHILE charinstring(dot,p,ss)DO ss:=CASE UPB ss IN cwd,IF ss =ds THEN
 cwd ELIF ss =sd THEN stroke ELIF ss = ".."THEN cwd LOP stroke ELIF dot BEGINS
 ss THEN flagdot+ss[2 ]ELSE ss[1 ]+flagdot FI OUT IF ss =dds THEN cwd LOP stroke
 ELIF ss[:3 ] =dds THEN cwd LOP stroke+ss[3 :]ELIF ss =sdd THEN stroke ELIF ss[:
2 ] =ds THEN ss[3 :]ELIF INT p1:=sd FIND ss;p1 =UPB ss-1 THEN ss[:p1-1 ]ELIF p1
>=1 THEN IF(UPB ss>p1+1 |ss[p1+2 ] =stroke|FALSE)THEN(p1>1 |ss[:p1-1 ]| "")+ss[
p1+2 :]ELIF(UPB ss>=p1+2 |ss[p1+2 ] =dot|FALSE)THEN ss[:p1-1 ]LOP stroke+(p1+2 <
UPB ss|ss[p1+3 :]| "")ELSE ss[:p1]+flagdot+ss[p1+2 :]FI ELIF INT p2:=ds FIND ss;
p2 =1 THEN cwd+ss[p2+1 :]ELIF p2>1 THEN IF ss[p2-1 ] =dot THEN ss[:p2-2 ]LOP
 stroke+ss[p2+1 :]ELSE ss[:p-1 ]+flagdot+ss[p+1 :]FI ELSE ss[:p-1 ]+flagdot+ss[p
+1 :]FI ESAC[@1 ]OD;replace(ss,flagdot,dot)FI;FILE monitorfile; SKIP;PROC
 monitor =([]UNION(SIMPLOUT,PROC(REF FILE)VOID)s)BOOL:IF open(monitorfile,idf(
monitorfile),standbackchannel)/=0 THEN FALSE ELSE set(monitorfile,0 ,0 ,
logicalend(monitorfile));put(monitorfile,s);close(monitorfile);TRUE FI;PROC
 startmonitor =(STRING fn)BOOL:IF establish(monitorfile,fn,standbackchannel,0 ,
0 ,0 )/=0 THEN FALSE ELSE put(monitorfile,( "Monitor log",newline, "==========="
,newline));close(monitorfile);TRUE FI;OP- =(CHAR a,b)[]CHAR:IF ABS a<=ABS b THEN
[ABS a:ABS b]CHAR s;FOR i FROM LWB s TO UPB s DO s[i]:=REPR i OD;s[@1 ]ELSE[ABS
 b:ABS a]CHAR s;FOR i FROM LWB s TO UPB s DO s[i]:=REPR i OD;s[@1 ]FI; SKIP;OP
 UC =(CHAR c)CHAR:(ABS c>=ABS "a"&ABS c<=ABS "z"|REPR(ABS c-32 )|c);OP TRIM =([]
CHAR s)[]CHAR:(INT lwb:=LWB s,upb:=UPB s;BOOL inws:=FALSE;FROM lwb TO upb WHILE
 ABS s[lwb]<=ABS blank DO lwb+:=1 OD;FROM upb BY-1 TO lwb WHILE ABS s[upb]<=ABS
 blank DO upb-:=1 OD;[lwb:upb]CHAR ss;INT sssz:=lwb-1 ;FOR i FROM lwb TO upb DO
 CHAR si =s[i];IF ABS si<=ABS blank THEN inws:=TRUE ELSE IF inws THEN ss[sssz+:=
1 ]:=blank;inws:=FALSE FI;ss[sssz+:=1 ]:=si FI OD;ss[:sssz]);#:9.1.1.1# #5.1.1.1
:# MODE STREAM =STRUCT(REF FILE f,BOOL ended,INT fnum,n,loc,upb,[4 ]INT sec,[
256 ]CHAR b,REF STREAM next);#:5.1.1.1 5.1.1.10:# MODE INCLUDED =STRUCT(STRING s
,INT n,REF INCLUDED left,right);#:5.1.1.10 6.2.1.2:# MODE CONTROL =STRUCT(CHAR
 cs);#:6.2.1.2 6.2.1.3:# MODE TAG =STRUCT(STRING s,REF TAG left,right);#:6.2.1.3
 6.2.1.4:# MODE TOKEN,MACRO,MODULE,#:6.2.1.4 6.2.1.5:# TEXT =STRUCT(UNION(TOKEN,
REF MACRO,REF MODULE)text,REF TEXT next),#:6.2.1.5 6.2.1.6:# MODULE =STRUCT(
STRING id,INT fnum,lnum,REF REF TEXT textbeg,textend,REF MODULE left,right),#:
6.2.1.6 6.2.1.7:# WPARAM =STRUCT(REF TAG par,REF WPARAM next),MACRO =STRUCT(REF
 TAG id,BITS flags,INT fnum,lnum,REF WPARAM param,REF REF TEXT textbeg,textend,
REF MACRO left,right),#:6.2.1.7 6.2.1.9:# TOKEN =UNION(INT,[]INT,CONTROL,STRING,
VOID,REF TAG);#:6.2.1.9 6.2.2.6:# MODE ADDMOD =STRUCT(INT e,REF MODULE mod);#:
6.2.2.6 6.2.2.10:# MODE ADDMAC =STRUCT(INT e,REF MACRO mac);#:6.2.2.10# #5.3.1.1
:# []CHAR outext = ".a68";#:5.3.1.1 7.1.1.2:# []CHAR boldrange =( "0"- "9")+( 
"A"- "Z"),idrange =blank+( "0"- "9")+ "_"+( "a"- "z");#:7.1.1.2# #5.1.1.2:# REF
 STREAM nostream =NIL;#:5.1.1.2 5.1.1.11:# REF INCLUDED noinc =NIL;#:5.1.1.11 
6.2.2.4:# REF MACRO nomac =NIL;REF MODULE nomod =NIL;REF WPARAM nowparam =NIL;
REF TAG notag =NIL;REF TEXT notext =NIL;#:6.2.2.4# #3.1.1.1:# BOOL debug:=FALSE;
#:3.1.1.1 3.1.1.2:# PROC(TOKEN)VOID debugprinttoken:=(TOKEN rt)VOID:SKIP;PROC(
STRING,TEXT)VOID debugprinttext:=(STRING s,TEXT t)VOID:SKIP;PROC(STRING,STRING)
VOID debugprintstring:=(STRING s,t)VOID:SKIP;#:3.1.1.2 4.1.1.1:# INT history:=0 
;#:4.1.1.1 4.1.1.2:# INT consolepos:=0 ;#:4.1.1.2 4.1.1.4:# BOOL phaseone:=TRUE;
#:4.1.1.4 5.1.1.7:# INT filenumber:=0 ;#:5.1.1.7 5.1.1.12:# REF INCLUDED inctree
:=noinc;#:5.1.1.12 5.1.1.14:# REF STREAM web:=HEAP STREAM:=(HEAP FILE,FALSE,0 ,
0 ,0 ,0 ,(0 ,0 ,0 ,0 ),256 *blank,nostream);STREAM output:=(HEAP FILE,FALSE,0 ,
0 ,0 ,0 ,(0 ,0 ,0 ,0 ),256 *blank,nostream);#:5.1.1.14 5.2.1.1:# STRING tangfn;
#:5.2.1.1 5.2.1.4:# STRING homedir;BOOL verbose:=TRUE,putskip:=TRUE;#:5.2.1.4 
5.2.1.8:# STRING includepaths:= ":"+TC "~/lib"+ ":";#:5.2.1.8 5.3.1.4:# STRING
 outfn;#:5.3.1.4 6.1.1.1:# INT curmood:=0 ;#:6.1.1.1 6.2.2.5:# REF MACRO
 macroroot:=nomac;REF MODULE moduleroot:=nomod;[0 :15 ]REF TAG tagroot;FOR i
 FROM LWB tagroot TO UPB tagroot DO tagroot[i]:=notag OD;#:6.2.2.5 6.2.2.12:# 
BOOL oneoffmacro:=FALSE;#:6.2.2.12 7.1.1.6:# REF MACRO curmac:=nomac;REF MODULE
 curmod:=nomod;MODULE unnamedmodule:=( "",0 ,0 ,HEAP REF TEXT:=notext,HEAP REF
 TEXT:=notext,nomod,nomod);textend OF unnamedmodule:=textbeg OF unnamedmodule;#:
7.1.1.6 7.2.1.5:# STRING incomment:= "";#:7.2.1.5 8.1.1.1:# BOOL tagoutput:=
FALSE;#:8.1.1.1# #3.1.1.3:# PROC showmood =(INT mood)[]CHAR:CASE mood+1 IN 
"limbo", "html", "macro id", "macro header", "macro body", "module body"OUT ""
ESAC+ " mood";#:3.1.1.3 3.1.1.4:# PROC monitorprinttoken =(TOKEN t)VOID:BEGIN
 monitor((idf(f OF web), ", l.",whole(n OF web,0 ), ":",CASE t IN(INT n): "INT("
+whole(n,0 )+ ")",(CONTROL c): "CONTROL("+cs OF c+ ")",(STRING st): "STRING("+st
+ ")",(VOID): "VOID",(REF TAG rt): "REF TAG("+s OF rt+ ")"ESAC,newline))END;#:
3.1.1.4 3.1.1.5:# PROC monitorprinttext =(STRING s,TEXT t)VOID:monitor((s,(text
 OF t|(INT n): "INT("+whole(n,0 )+ ")",([]INT r): "[]INT("+whole(r[1 ],0 )+ "."+
whole(r[2 ],0 )+ "."+whole(r[3 ],0 )+ "."+whole(r[4 ],0 )+ ")",(STRING st): 
"STRING("+st+ ")",(REF TAG tg): "REF TAG("+s OF tg+ ")",(REF MACRO mc): 
"REF MACRO("+s OF id OF mc+ ")",(REF MODULE md): "REF MODULE("+id OF md+ ")",(
VOID): "VOID",(CONTROL c): "CONTROL("+cs OF c+ ")"),newline));#:3.1.1.5 3.1.1.6
:# PROC monitorprintstring =(STRING s,t)VOID:monitor((s, ":",t,newline));#:
3.1.1.6# #4.1.1.3:# PROC printout =([]UNION(STRING,CHAR,INT,VOID)s)VOID:FOR i
 FROM LWB s TO UPB s DO STRING outs =CASE s[i]IN(STRING si):si,(CHAR ci):ci,(INT
 ni):whole(ni,0 ),(VOID):(print(newline);consolepos:=0 ; "")ESAC;IF consolepos+
UPB outs>80 THEN print(newline);consolepos:=0 FI;print(outs);consolepos+:=UPB
 outs OD;#:4.1.1.3 4.1.1.5:# PROC error =(INT status)VOID:IF IF history<status
 THEN history:=status FI;phaseone THEN#4.1.1.6:# printout(( ". (",idf(f OF web),
 ", l.",n OF web, ")",EMPTY));FOR k TO loc OF web DO printout((CHAR bk =(b OF
 web)[k];bk =tabch|blank|bk))OD;printout((EMPTY,loc OF web*blank,(loc OF web<upb
 OF web|(b OF web)[loc OF web+1 :upb OF web]| "")));printout(blank)#:4.1.1.6# 
ELSE#4.1.1.7:# printout(( ". (l.",n OF output, ")",EMPTY,(b OF output)[upb OF
 output], "... ",EMPTY))#:4.1.1.7# FI;#:4.1.1.5 4.1.1.9:# PROC simpleerror =(
STRING s,INT halt)VOID:(print((newline, "! Error: ",s));exit(halt));#:4.1.1.9# #
7.1.1.3:# PRIO CHOP =7 ;OP CHOP =(CHAR c,[]CHAR s)INT:BEGIN INT bot:=LWB s,top:=
UPB s;INT i:=(bot+top)OVER 2 ;WHILE CHAR si;(bot<=top|(si:=s[i])/=c|FALSE)DO(c<
si|top:=i-1 |bot:=i+1 );i:=(bot+top)OVER 2 OD;(bot<=top|i|LWB s-1 )END;#:7.1.1.3
 7.2.1.6:# OP COMPACT =([]CHAR tag)[]CHAR:BEGIN[LWB tag:UPB tag]CHAR loctag;INT
 n:=LWB tag-1 ;FOR i FROM LWB tag TO UPB tag DO IF CHAR ti =tag[i];ti/=blank&ti
/=tabch THEN loctag[n+:=1 ]:=ti FI OD;loctag[:n]END;#:7.2.1.6 7.4.1.1:# OP
 MULTICASE =(CHAR c,[]STRING s)INT:BEGIN INT j:=LWB s-1 ;FOR i FROM LWB s TO UPB
 s WHILE j<LWB s DO IF STRING si =s[i];c CHOP si>=LWB si THEN j:=i FI OD;j END;
#:7.4.1.1# #5.1.1.4:# PROC searchwithfilenumber =(REF REF INCLUDED tr,INT fnum)
STRING:IF tr IS noinc THEN ""ELIF fnum =n OF tr THEN s OF tr ELIF left OF tr
 ISNT noinc THEN searchwithfilenumber(left OF tr,fnum)ELIF right OF tr ISNT
 noinc THEN searchwithfilenumber(right OF tr,fnum)ELSE ""FI;#:5.1.1.4 5.1.1.9:# 
PROC scanincludedtree =(REF REF INCLUDED tr,STRING fn)BOOL:IF tr IS noinc THEN
 FALSE ELIF fn =s OF tr THEN TRUE ELIF fn<s OF tr THEN scanincludedtree(left OF
 tr,fn)ELSE scanincludedtree(right OF tr,fn)FI;#:5.1.1.9 5.2.1.7:# PROC usage =
VOID:BEGIN put(standerror,( "Usage: tang -d|-h|-s|-V|-v|-(tw)path tang-file",
newline, " -d: output debugging data to tang.dbg",newline, 
" -e: output SALTU instead of SKIP",newline, " -h: this message",newline, 
" -V: don't output comments in the output source",newline, " -v: version",
newline, " -t or -w: include path to be added to ~/lib",newline, 
"tang-file: main input file",newline,newline));exit(1 )END;#:5.2.1.7 6.2.2.1:# 
PROC inccursec =(INT level)VOID:IF level>=1 &level<=3 THEN(sec OF web)[level]+:=
1 ;FOR i FROM level+1 TO UPB(sec OF web)DO(sec OF web)[i]:=1 OD ELIF level =4 
THEN(sec OF web)[level]+:=1 FI;#:6.2.2.1 6.2.2.2:# PROC printcursec =VOID:
printout(( "[",(fnum OF web>0 | "I"+whole(fnum OF web,0 )|(sec OF web)[1 ]), "."
,(sec OF web)[2 ], ".",(sec OF web)[3 ], ".",(sec OF web)[4 ], "]"));#:6.2.2.2 
6.2.2.3:# PROC maketext =([]INT cursec)TEXT:BEGIN[4 ]INT cs:=cursec;IF next OF
 web ISNT nostream THEN cs[1 ]:=-fnum OF web FI;TEXT(cs,notext)END;#:6.2.2.3 
6.2.2.8:# PROC addmoduletag =(REF REF MODULE root,STRING s,BOOL adding,prefix)
ADDMOD:IF root IS nomod THEN IF prefix THEN(3 ,nomod)ELIF adding THEN root:=HEAP
 MODULE:=(s,fnum OF web,n OF web,HEAP REF TEXT:=notext,HEAP REF TEXT:=notext,
nomod,nomod);textend OF root:=textbeg OF root;(1 ,root)ELSE(1 ,nomod)FI ELIF UPB
 s>UPB id OF root THEN IF s<id OF root THEN addmoduletag(left OF root,s,adding,
prefix)ELSE addmoduletag(right OF root,s,adding,prefix)FI ELIF prefix THEN IF
 STRING idpref =(id OF root)[:UPB s];s =idpref THEN IF ADDMOD resl =addmoduletag
(left OF root,s,FALSE,TRUE),resr =addmoduletag(right OF root,s,FALSE,TRUE);e OF
 resl =3 AND e OF resr =3 THEN(2 ,root)ELSE(4 ,root)FI ELIF s<id OF root THEN
 addmoduletag(left OF root,s,adding,prefix)ELSE addmoduletag(right OF root,s,
adding,prefix)FI ELIF s =id OF root THEN(0 ,root)ELIF s<id OF root THEN
 addmoduletag(left OF root,s,adding,prefix)ELSE addmoduletag(right OF root,s,
adding,prefix)FI;#:6.2.2.8 6.2.2.9:# PROC addtag =(REF[]REF TAG root,REF TAG tag
)REF TAG:BEGIN OP HASH =(STRING s)INT:(ABS s[LWB s]+2 *ABS s[UPB s])MOD(1 +UPB
 tagroot);PROC locaddtag =(REF REF TAG r,REF TAG t)REF TAG:IF r IS notag THEN r
:=t ELIF s OF t =s OF r THEN r ELIF s OF t<s OF r THEN locaddtag(left OF r,t)
ELSE locaddtag(right OF r,t)FI;locaddtag(root[HASH s OF tag],tag)END;#:6.2.2.9 
6.2.2.11:# PROC addmacroid =(REF REF MACRO root,REF TAG tag,BOOL once)ADDMAC:IF
 root IS nomac THEN root:=HEAP MACRO:=(tag,BIN ABS once,fnum OF web,n OF web,
nowparam,HEAP REF TEXT:=notext,HEAP REF TEXT:=notext,nomac,nomac);textend OF
 root:=textbeg OF root;(0 ,root)ELIF s OF tag =s OF id OF root THEN(1 ,root)ELIF
 s OF tag<s OF id OF root THEN addmacroid(left OF root,tag,once)ELSE addmacroid(
right OF root,tag,once)FI;#:6.2.2.11 6.2.2.13:# PROC addmacropar =(REF MACRO rm,
REF TAG par)BOOL:IF param OF rm IS nowparam THEN param OF rm:=HEAP WPARAM:=(par,
nowparam);TRUE ELIF REF REF WPARAM locpar:=param OF rm;WHILE IF locpar ISNT
 nowparam THEN s OF par/=s OF par OF locpar ELSE FALSE FI DO locpar:=next OF
 locpar OD;locpar IS nowparam THEN REF REF WPARAM(locpar):=HEAP WPARAM:=(par,
nowparam);TRUE ELSE FALSE FI;#:6.2.2.13 6.2.2.14:# PROC addmactext =(REF MACRO
 rmc,TEXT t)VOID:(REF REF TEXT(textbeg OF rmc:=:notext|textbeg OF rmc|textend OF
 rmc):=HEAP TEXT:=t;textend OF rmc:=next OF textend OF rmc);#:6.2.2.14 6.2.2.15
:# PROC addmodtext =(REF MODULE rmd,TEXT t)VOID:(REF REF TEXT(textbeg OF rmd:=:
notext|textbeg OF rmd|textend OF rmd):=HEAP TEXT:=t;textend OF rmd:=next OF
 textend OF rmd);#:6.2.2.15 7.3.1.7:# PROC searchmacro =(REF REF MACRO root,REF
 TAG t)REF MACRO:IF root IS nomac THEN nomac ELIF s OF t =s OF id OF root THEN
 root ELIF s OF t<s OF id OF root THEN searchmacro(left OF root,t)ELSE
 searchmacro(right OF root,t)FI;#:7.3.1.7 8.1.1.2:# PROC putout =(REF STREAM st,
[]UNION(CHAR,STRING,INT,[]INT,REF TAG)p)VOID:BEGIN PROC emptythebuffer =(REF
 STREAM st)VOID:(IF CHAR b1 =(b OF st)[1 ];b1 = "*"OR b1 = "%"THEN put(f OF st,
blank)FI;put(f OF st,((b OF st)[:upb OF st],newline));n OF st+:=1 ;upb OF st:=0 
);FOR i FROM LWB p TO UPB p DO[]CHAR outs =CASE p[i]IN(CHAR ci):ci,(STRING si):
IF CHAR sil =si[LWB si];tagoutput&(sil>= "0"&sil<= "9"OR sil = ".")THEN
 tagoutput:=FALSE;blank+si+blank ELIF(sil>= "0"&sil<= "9"OR sil = ".")THEN si+
blank ELIF tagoutput:=FALSE;si = "="THEN blank+si ELSE si FI,(INT):(
emptythebuffer(st);tagoutput:=FALSE; ""),([]INT ri):(tagoutput:=FALSE;(ri[1 ]<0 
| "I"| "")+whole(ABS ri[1 ],0 )+ "."+whole(ri[2 ],0 )+ "."+whole(ri[3 ],0 )+ "."
+whole(ri[4 ],0 )),(REF TAG ti):(tagoutput|blank|tagoutput:=TRUE; "")+s OF ti
 ESAC;IF upb OF st+UPB outs>80 THEN emptythebuffer(st)FI;(b OF st)[upb OF st+1 :
upb OF st+UPB outs]:=outs;upb OF st+:=UPB outs OD END;#:8.1.1.2 8.2.1.1:# PROC
 expandmacro =(REF REF TEXT txt,REF MACRO mc)BOOL:IF REF TEXT newtext:=notext,
locmactext:=textbeg OF mc;REF REF TEXT locnewtext:=newtext;param OF mc IS
 nowparam THEN WHILE IF locmactext IS notext THEN FALSE ELSE NOT(text OF
 locmactext|(VOID):TRUE|FALSE)FI DO REF REF TEXT(locnewtext):=HEAP TEXT:=(text
 OF locmactext,notext);locnewtext:=next OF locnewtext;locmactext:=next OF
 locmactext OD;REF REF TEXT(locnewtext):=next OF txt;txt:=newtext;FALSE ELSE#
8.2.1.2:# MODE ACTUAL =STRUCT(REF TEXT actual,REF ACTUAL next);REF ACTUAL
 noactual =NIL;REF ACTUAL actualparam:=noactual;#:8.2.1.2 8.2.1.3:# REF REF
 WPARAM locformalparam:=param OF mc;REF REF ACTUAL locactualparam:=actualparam;
WHILE locformalparam ISNT nowparam DO REF REF ACTUAL(locactualparam):=HEAP
 ACTUAL:=(notext,noactual);locactualparam:=next OF locactualparam;locformalparam
:=next OF locformalparam OD;#:8.2.1.3 8.2.1.4:# IF(text OF next OF txt|(STRING s
):s| "")/=STRING( "(")THEN(print(newline);consolepos:=0 ;printout(( "! Error: ",
 "call of macro "+s OF id OF mc+ " not followed by ""("""+ 
", macro call ignored"));error(2 ));TRUE ELSE#:8.2.1.4 8.2.1.5:# REF REF TEXT
 loctext:=next OF next OF txt;#:8.2.1.5 8.2.1.6:# locactualparam:=actualparam;
WHILE IF locactualparam IS noactual THEN FALSE ELSE NOT(text OF loctext|(VOID):
TRUE|FALSE)FI DO INT level:=0 ;actual OF locactualparam:=loctext;WHILE STRING
 curtxt =(text OF loctext|(STRING s):s| "");NOT((text OF loctext|(VOID):TRUE|
FALSE)OR level =0 AND(curtxt = ")"OR curtxt = ","))DO IF curtxt = "("THEN level
+:=1 ELIF curtxt = ")"THEN level-:=1 FI;loctext:=next OF loctext OD;IF(text OF
 loctext|(VOID):TRUE|FALSE)THEN(print(newline);consolepos:=0 ;printout(( 
"! Error: ", "unexpected end of text"));error(2 ))ELIF(text OF loctext|(STRING s
):s| "") =STRING( ")")&(next OF locactualparam ISNT noactual)THEN(printout((
EMPTY, "! Fatal error: insufficient parameters in a macro call"));error(2 );
close(f OF output);exit(-1 ))ELIF(text OF loctext|(STRING s):s| "") =STRING( ","
)&(next OF locactualparam IS noactual)THEN(printout((EMPTY, 
"! Fatal error: too many parameters in a macro call"));error(2 );close(f OF
 output);exit(-1 ))ELSE REF REF TEXT tmptext =loctext;loctext:=next OF loctext;
tmptext:=notext;locactualparam:=next OF locactualparam FI OD;#:8.2.1.6 8.2.1.7
:# WHILE locmactext ISNT notext DO CASE text OF locmactext IN(REF TAG tag):IF#
8.2.1.9:# locformalparam:=param OF mc;locactualparam:=actualparam;WHILE IF
 locformalparam IS nowparam THEN FALSE ELSE tag ISNT par OF locformalparam FI DO
 locformalparam:=next OF locformalparam;locactualparam:=next OF locactualparam
 OD;locformalparam IS nowparam#:8.2.1.9# THEN REF REF TEXT(locnewtext):=HEAP
 TEXT:=(text OF locmactext,notext);locnewtext:=next OF locnewtext ELSE REF REF
 TEXT locactualparamtext:=actual OF locactualparam;WHILE locactualparamtext ISNT
 notext DO REF REF TEXT(locnewtext):=HEAP TEXT:=locactualparamtext;locnewtext:=
next OF locnewtext;locactualparamtext:=next OF locactualparamtext OD FI OUT REF
 REF TEXT(locnewtext):=HEAP TEXT:=(text OF locmactext,notext);locnewtext:=next
 OF locnewtext ESAC;locmactext:=next OF locmactext OD;#8.2.1.8:# REF REF TEXT(
locnewtext):=loctext;txt:=newtext#:8.2.1.8# ;FALSE FI#:8.2.1.7# FI;#:8.2.1.1 
8.3.1.2:# PROC processmodule =(REF STREAM st,REF MODULE mod,REF[]INT cursec)VOID
:IF textbeg OF mod:=:notext THEN(print(newline);consolepos:=0 ;printout(( 
"Module """,id OF mod, """ has no text!",EMPTY));error(1 ))ELSE cursec:=(text OF
 textbeg OF mod|([]INT n):n|(0 ,0 ,0 ,0 ));IF verbose THEN putout(st,( "#",
cursec, ":# "))FI;REF REF TEXT loctxt:=next OF textbeg OF mod;WHILE loctxt ISNT
 notext DO debugprinttext( "process module: ",loctxt);IF#8.3.1.3:# CASE text OF
 loctxt IN(INT n):(putout(st,n);TRUE),([]INT r):(IF verbose THEN putout(st,( 
"#:",cursec,blank));putout(st,(cursec:=r, ":# "))ELSE cursec:=r FI;TRUE),(STRING
 s):((s[LWB s] = """"|putout(st,blank));putout(st,s);TRUE),(REF TAG t):(putout(
st,t);TRUE),(REF MACRO mc):#8.3.1.4:# IF 32 ELEM flags OF mc THEN IF NOT(31 ELEM
 flags OF mc)THEN flags OF mc:=flags OF mc OR ELEM 31 ;expandmacro(loctxt,mc)
ELSE putout(st,(putskip| " SKIP"| " SALTU"));TRUE FI ELSE expandmacro(loctxt,mc)
FI#:8.3.1.4# ,(REF MODULE md):(processmodule(st,md,HEAP[4 ]INT);TRUE),(VOID):
TRUE,(CONTROL c):BEGIN(print(newline);consolepos:=0 ;printout(( "! Error: ", 
"unexpected control sequence("+cs OF c+ ") in module """+id OF mod+ """"));error
(2 ));TRUE END ESAC#:8.3.1.3# THEN loctxt:=next OF loctxt FI OD;IF verbose THEN
 putout(st,( "#:",cursec, "# "))FI FI;#:8.3.1.2# #5.1.1.3:# PROC addfiletotree =
(REF REF INCLUDED tr,STRING fn,INT fnum)VOID:IF tr IS noinc THEN tr:=HEAP
 INCLUDED:=(fn,fnum,noinc,noinc)ELIF fn<s OF tr THEN addfiletotree(left OF tr,fn
,fnum)ELIF fn>s OF tr THEN addfiletotree(right OF tr,fn,fnum)ELSE SKIP FI;#:
5.1.1.3 5.1.1.5:# PROC addincludefile =(REF REF STREAM web,STRING incfn)BOOL:IF
 HEAP FILE incf;open(incf,incfn,standinchannel) =0 THEN filenumber+:=1 ;#5.1.1.6
:# web:=HEAP STREAM:=(incf,FALSE,filenumber,0 ,0 ,0 ,(filenumber,0 ,0 ,0 ),256 *
blank,web);#:5.1.1.6# addfiletotree(inctree,incfn,filenumber);TRUE ELSE#5.1.1.8
:# FILE pf;STRING path;open(pf,MAKERVC includepaths,memchannel);maketerm(pf, ":"
);onlogicalfileend(pf,(REF FILE f)BOOL:(close(f);GOTO eof;SKIP));DO get(pf,(
skipterminators,path));IF path[UPB path]/= "/"THEN path+:= "/"FI;IF open(incf,
path+incfn,standinchannel) =0 THEN filenumber+:=1 ;#5.1.1.6:# web:=HEAP STREAM:=
(incf,FALSE,filenumber,0 ,0 ,0 ,(filenumber,0 ,0 ,0 ),256 *blank,web);#:5.1.1.6
# close(pf);addfiletotree(inctree,incfn,filenumber);GOTO found ELSE
 debugprintstring( "looking for include file",path+incfn)FI OD;eof:FALSE EXIT
 found:TRUE#:5.1.1.8# FI;#:5.1.1.5 7.1.1.1:# PROC inputln =(REF STREAM inp)BOOL:
BEGIN CHAR ch;upb OF inp:=0 ;loc OF inp:=0 ;onlogicalfileend(f OF inp,(REF FILE
 f)BOOL:(ended OF inp:=TRUE;GOTO lab1;SKIP));WHILE getbin(f OF inp,ch);ch/=lf DO
(b OF inp)[upb OF inp+:=1 ]:=ch OD;IF upb OF inp>0 THEN[]CHAR trimmedb =(TRIM(b
 OF inp)[:upb OF inp])[@1 ];upb OF inp:=UPB trimmedb;(b OF inp)[:upb OF inp]:=
trimmedb FI;n OF inp+:=1 ;TRUE EXIT lab1:FALSE END;#:7.1.1.1 7.1.1.4:# PROC
 nextchar =(BOOL processunicode)CHAR:IF ended OF web THEN#5.1.1.13:# IF next OF
 web ISNT nostream THEN close(f OF web);web:=next OF web FI#:5.1.1.13# ;blank
 ELIF loc OF web<upb OF web THEN IF processunicode THEN REF CHAR ch1 =(b OF web)
[loc OF web+:=1 ];REF CHAR ch2 =(loc OF web<upb OF web|(b OF web)[loc OF web+1 ]
|LOC CHAR);IF ABS ch1>127 THEN#7.1.1.5:# IF BITS bch1 =BIN ABS ch1;bch1 =16rc4 
OR bch1 =16rc5 THEN INT pos;BOOL upper:=FALSE;OP B =(BITS b)CHAR:REPR ABS b;ch1
:=IF bch1 =16rc4 THEN IF charinstring(ch2,pos,(B 16r88 ,B 16r9c ,B 16ra4 ,B
 16rb4 ,B 16r89 ,B 16r9d ,B 16ra5 ,B 16rb5 ))THEN upper:=pos<5 ; "CGHJcghj"[pos]
ELSE(print(newline);consolepos:=0 ;printout(( "! Error: ", 
"unknown unicode character: "+HEX SHORTEN SHORTEN BIN ABS ch2));error(2 )); "x"
FI ELIF charinstring(ch2,pos,(B 16r9c ,B 16rac ,B 16r9d ,B 16rad ))THEN upper:=
pos<3 ; "SUsu"[pos]ELSE(print(newline);consolepos:=0 ;printout(( "! Error: ", 
"unknown unicode character: "+HEX SHORTEN SHORTEN BIN ABS ch2));error(2 )); "x"
FI;ch2:=(upper| "X"| "x")ELSE(print(newline);consolepos:=0 ;printout(( 
"! Error: ", "unknown unicode character: "+HEX SHORTEN SHORTEN BIN ABS ch1));
error(2 ))FI#:7.1.1.5# FI;ch1 ELSE(b OF web)[loc OF web+:=1 ]FI ELSE WHILE IF
 inputln(web)THEN upb OF web =0 ELSE FALSE FI DO SKIP OD;IF ended OF web THEN#
5.1.1.13:# IF next OF web ISNT nostream THEN close(f OF web);web:=next OF web FI
#:5.1.1.13# FI;blank FI;#:7.1.1.4 7.1.1.7:# PROC gathertochar =(CHAR c)[]CHAR:IF
 INT curline =n OF web,curchar =loc OF web;CHAR ch;STRING s;WHILE ch:=nextchar(
FALSE);NOT ended OF web&ch/=c DO s+:=ch OD;ended OF web THEN(print(newline);
consolepos:=0 ;printout(( "! Error: ", "input ended while gathering from l."+
whole(curline,0 )+ ",c."+whole(curchar,0 )+ " to "+c));error(2 )); ""ELSE s+:=ch
 FI;#:7.1.1.7 7.1.1.8:# PROC skiptochar =(CHAR c)VOID:BEGIN CHAR ch;WHILE ch:=
nextchar(FALSE);NOT ended OF web&ch/=c DO SKIP OD;IF ended OF web THEN(print(
newline);consolepos:=0 ;printout(( "! Error: ", "input ended while skipping to "
+c));error(2 ))FI END;#:7.1.1.8 7.1.1.9:# PROC skiptobang =BOOL:BEGIN CHAR ch;
WHILE WHILE ch:=nextchar(FALSE);NOT ended OF web&ch/= "!"&ch/= "@"DO SKIP OD;IF
 ended OF web OR ch = "!"THEN FALSE ELIF(ch:=nextchar(FALSE))/= "@"THEN(print(
newline);consolepos:=0 ;printout(( "! Error: ", "control sequence inside !...!")
);error(2 ));(NOT ended OF web|TO 2 DO(loc OF web>=LWB b OF web|loc OF web-:=1 )
OD);GOTO err ELSE TRUE FI DO SKIP OD;TRUE EXIT err:FALSE END;#:7.1.1.9 7.1.1.10
:# PROC skiptocs =([]CHAR cset)VOID:WHILE IF ended OF web THEN FALSE ELSE CHAR
 ch:=nextchar(FALSE);CASE ch FIND """{@"IN(skiptochar(ch);TRUE),(#7.1.1.11:# INT
 bal:=1 ;WHILE ch:=nextchar(FALSE);NOT(ch = "}"&bal =1 )DO IF ch = "{"THEN bal
+:=1 ELIF ch = "}"THEN bal-:=1 FI OD#:7.1.1.11# ;TRUE),NOT charinstring(UC
 nextchar(FALSE),LOC INT,cset)OUT TRUE ESAC FI DO SKIP OD;#:7.1.1.10 7.2.1.1:# 
PROC gettok =(BOOL recursive)TOKEN:BEGIN TOKEN t;STRING s;BOOL valid:=TRUE;WHILE
 CHAR ch:=nextchar(NOT FALSE);IF ended OF web THEN t:=EMPTY;FALSE ELIF ch =blank
 OR ch =tabch THEN TRUE ELIF(ch>= "A"&ch<= "Z")THEN#7.2.1.2:# s:=ch;WHILE IF loc
 OF web =upb OF web THEN FALSE ELSE valid:=(ch:=nextchar(NOT FALSE))CHOP
 boldrange>=LWB boldrange FI DO s+:=ch OD;IF NOT valid THEN(loc OF web>=LWB b OF
 web|loc OF web-:=1 )FI;#:7.2.1.2 7.2.1.3:# IF s/= "CO"AND s/= "COMMENT"THEN t:=
HEAP TAG:=(s,notag,notag);FALSE ELIF recursive THEN t:=s;FALSE ELIF#7.2.1.4:# 
incomment:=s;WHILE CASE gettok(TRUE)IN(STRING str):str/=incomment,(VOID):FALSE
 OUT TRUE ESAC DO SKIP OD;incomment:= "";#:7.2.1.4# ended OF web THEN(print(
newline);consolepos:=0 ;printout(( "! Error: ", 
"input ended while searching for "+incomment));error(2 ));t:=EMPTY;FALSE ELSE
 TRUE FI#:7.2.1.3# ELIF(ch>= "a"&ch<= "z"OR ch = "_")THEN#7.2.1.7:# s:=ch;WHILE
 IF ended OF web THEN FALSE ELSE valid:=(ch:=nextchar(NOT FALSE))CHOP idrange>=
LWB idrange FI DO s+:=ch OD;IF NOT valid THEN(loc OF web>=LWB b OF web|loc OF
 web-:=1 )FI;t:=HEAP TAG:=(COMPACT s,notag,notag);FALSE#:7.2.1.7# ELIF(ch>= "0"&
ch<= "9"OR ch = ".")THEN#7.2.1.8:# s:=ch;WHILE IF ch:=nextchar(NOT FALSE);ended
 OF web THEN FALSE ELSE ch>= "0"&ch<= "9"OR ch CHOP " .abcdefr">0 FI DO s+:=ch
 OD;(loc OF web>=LWB b OF web|loc OF web-:=1 );t:=COMPACT STRING(s);FALSE#:
7.2.1.8# ELIF ch = "@"THEN#7.2.1.9:# t:=IF ch:=nextchar(NOT FALSE);ended OF web
 THEN EMPTY ELSE HEAP CONTROL h;cs OF h:=ch;h FI;FALSE#:7.2.1.9# ELSE#7.2.1.10
:# IF ch = """"THEN#7.2.1.11:# s:=ch;WHILE s+:=gathertochar(ch);(ch:=nextchar(
NOT FALSE)) = """"DO s+:=ch OD;(loc OF web>=LWB b OF web|loc OF web-:=1 );#
7.2.1.12:# INT nat:=0 ;BOOL err:=FALSE;FOR i FROM LWB s TO UPB s DO nat+:=ABS(s[
i] = "@")OD;IF ODD nat THEN(print(newline);consolepos:=0 ;printout(( "! Error: "
, "odd number of @-symbols in a string"));error(2 ))ELIF nat>0 THEN[LWB s:UPB s-
nat%2 ]CHAR ss;INT pss:=LWB ss-1 ;BOOL atread:=FALSE;FOR i FROM LWB s TO UPB s
 WHILE NOT err DO CHAR si =s[i];IF si = "@"THEN IF atread THEN ss[pss+:=1 ]:=si;
atread:=FALSE ELSE atread:=TRUE FI ELIF atread THEN(print(newline);consolepos:=
0 ;printout(( "! Error: ", "single @-symbol in a string"));error(2 ));atread:=
FALSE;err:=TRUE ELSE ss[pss+:=1 ]:=si FI OD;s:=(err| ""|ss)FI;(err|TRUE|t:=s;
FALSE)#:7.2.1.12# #:7.2.1.11# ELIF ch = "#"THEN skiptochar(ch);TRUE ELIF ch = 
"{"THEN skiptochar( "}");TRUE ELIF ch CHOP "$(),=[\]">0 THEN t:=STRING(ch);FALSE
 ELIF ch = ":"THEN s:=ch;WHILE charinstring(ch:=nextchar(NOT FALSE),LOC INT, 
"%&*+-/:<=>^")DO s+:=ch OD;(loc OF web>=LWB b OF web|loc OF web-:=1 );t:=s;FALSE
 ELIF ch CHOP "%&*+-/:<=>^" =0 THEN t:=STRING(ch);FALSE ELSE WHILE s+:=ch;ch:=
nextchar(NOT FALSE);ch CHOP "%&*+-/:<=>^">0 DO SKIP OD;(loc OF web>=LWB b OF web
|loc OF web-:=1 );t:=STRING(s);FALSE FI#:7.2.1.10# FI DO SKIP OD;debugprinttoken
(t);t END;#:7.2.1.1 7.3.1.2:# PROC gathertocs =(CHAR c)STRING:BEGIN STRING s;
CHAR ch;BOOL sp:=FALSE;WHILE IF ended OF web THEN(print(newline);consolepos:=0 ;
printout(( "! Error: ", "end of file while gathering to @"+c));error(2 ));FALSE
 ELIF(ch:=nextchar(FALSE)) = "@"THEN IF(ch:=nextchar(FALSE)) =c THEN FALSE ELSE
 s+:= "@"+ch;TRUE FI ELIF ch =blank OR ch =tabch THEN IF NOT sp THEN s+:=ch;sp:=
TRUE ELSE TRUE FI ELSE s+:=ch;NOT(sp:=FALSE)FI DO SKIP OD;s END;#:7.3.1.2# #:
1.1.1.2 5.2.1.2:# #5.2.1.3:# IF FILE hf;open(hf, "HOME",envchannel)/=0 THEN
 simpleerror( "HOME undefined",5 )ELSE get(hf,homedir);close(hf)FI;#:5.2.1.3# #
5.2.1.5:# open(LOC FILE, "",argchannel);#:5.2.1.5# #5.2.1.6:# IF argc =1 THEN
 usage ELSE FOR i FROM 2 TO argc DO[]CHAR arg =CSTRTORVC argv[i];IF arg = "-d"
THEN debug:=TRUE ELIF arg = "-h"THEN usage ELIF arg = "-e"THEN putskip:=FALSE
 ELIF arg = "-V"THEN verbose:=FALSE ELIF arg = "-v"THEN put(standerr,( 
"This is tang, version ", "1.13 2013-01-25 08:57:00 sian", 
" (C) 2013 Sian Mountbatten",newline));exit(1 )ELIF UPB arg>=2 THEN IF arg[:2 ]
 = "-w"OR arg[:2 ] = "-t"THEN IF UPB arg<3 THEN simpleerror(arg[:2 ]+ 
": missing path",5 )ELSE STRING path:=arg[3 :];#5.2.1.9:# path:=NORM path#:
5.2.1.9# ;#5.2.1.10:# (path+ ":")PLUSTO includepaths#:5.2.1.10# FI ELSE tangfn:=
arg FI ELSE tangfn:=arg FI OD FI;#:5.2.1.6# #:5.2.1.2 5.3.1.2:# IF open(f OF web
,tangfn,standinchannel)/=0 THEN simpleerror( "cannot open web 68 file "+tangfn,
2 )ELSE addfiletotree(inctree,tangfn,0 )FI;#:5.3.1.2 5.3.1.3:# outfn:=(tangfn
 UPTO ".")+outext;IF establish(f OF output,outfn,standoutchannel,0 ,0 ,0 )/=0 
THEN simpleerror( "cannot establish the output file "+outfn,3 )ELSE
 onphysicalfileend(f OF output,(REF FILE f)BOOL:((print(newline);consolepos:=0 ;
printout(( "! Error: ", "output medium full"));error(2 ));exit(-1 );TRUE));n OF
 output:=1 ;loc OF output:=0 FI;#:5.3.1.3 5.3.1.5:# IF debug THEN startmonitor( 
"tang.dbg");debugprinttoken:=monitorprinttoken;debugprinttext:=monitorprinttext;
debugprintstring:=monitorprintstring FI;#:5.3.1.5 6.1.1.2:# #6.1.1.3:# WHILE
 skiptocs( "=\ 123");(loc OF web>=LWB b OF web|loc OF web-:=1 );CHAR ch =
nextchar(FALSE);NOT charinstring(ch,LOC INT, " 123")DO IF ch = "\"THEN putout(
output,0 )ELIF STRING s =gathertochar( "@");nextchar(FALSE)/= ">"THEN(print(
newline);consolepos:=0 ;printout(( "! Error: ", 
"no control sequences allowed in @=...@>"));error(2 ))ELSE putout(output,s[:UPB
 s-1 ])FI OD;(NOT ended OF web|TO 2 DO(loc OF web>=LWB b OF web|loc OF web-:=1 )
OD)#:6.1.1.3# ;curmood:=1 ;(NOT ended OF web|TO 2 DO(loc OF web>=LWB b OF web|
loc OF web-:=1 )OD);DO debugprintstring( "Outer DO loop",showmood(curmood));IF
 curmood =1 THEN skiptocs( " 123<ADIM");(NOT ended OF web|TO 2 DO(loc OF web>=
LWB b OF web|loc OF web-:=1 )OD)FI;HEAP TOKEN curtok:=gettok(FALSE);#7.3.1.3:# 
CASE curtok IN(INT):SKIP,(CONTROL co):#7.4.1.2:# CASE UC cs OF co MULTICASE[]
STRING( "!,/", ".H^",tabch+blank, "=")IN SKIP,skiptocs( ">"),(inccursec(4 );
curmood:=1 ),IF curmood =4 THEN addmactext(curmac,TEXT(gathertocs( ">"),notext))
ELIF curmood =5 THEN addmodtext(curmod,TEXT(gathertocs( ">"),notext))ELSE(print(
newline);consolepos:=0 ;printout(( "! Error: ", "@= not in macro/module body"));
error(2 ));skiptocs( ">")FI OUSE UC cs OF co CHOP "123<@ADIM\"IN#7.4.1.3:# IF
 next OF web ISNT nostream THEN(print(newline);consolepos:=0 ;printout(( 
"! Error: ", "level-1 sections are disallowed in included files"));error(2 ))
ELSE inccursec(1 );curmood:=1 FI,(inccursec(2 );curmood:=1 ),(inccursec(3 );
curmood:=1 ),#7.4.1.5:# CASE STRING mtag:=(TRIM gathertocs( ">"))[@1 ];CHAR ch =
nextchar(NOT FALSE);curmood IN IF ch = "="THEN#7.4.1.6:# IF UPB mtag>3 THEN IF
 mtag[UPB mtag-2 :] = "..."THEN ADDMOD res =addmoduletag(moduleroot,mtag[:UPB
 mtag-3 ],FALSE,TRUE);CASE e OF res-1 IN BEGIN addmodtext(curmod:=mod OF res,
maketext(sec OF web));curmood:=5 END,(print(newline);consolepos:=0 ;printout(( 
"! Error: ", "unknown module prefix"));error(2 )),BEGIN STRING fn =
searchwithfilenumber(inctree,fnum OF mod OF res);(print(newline);consolepos:=0 ;
printout(( "! Error: ", "prefix starts more than one module. The previously"+lf+
 "defined module is in file "+fn+ " l."+whole(lnum OF mod OF res,0 )));error(2 )
);curmood:=1 END ESAC ELSE#7.4.1.7:# curmood:=5 ;addmodtext(curmod:=mod OF
 addmoduletag(moduleroot,mtag,TRUE,FALSE),maketext(sec OF web))#:7.4.1.7# FI
 ELSE#7.4.1.7:# curmood:=5 ;addmodtext(curmod:=mod OF addmoduletag(moduleroot,
mtag,TRUE,FALSE),maketext(sec OF web))#:7.4.1.7# FI#:7.4.1.6# ELSE(loc OF web>=
LWB b OF web|loc OF web-:=1 )FI,(IF ch/= "="THEN(loc OF web>=LWB b OF web|loc OF
 web-:=1 )FI;(print(newline);consolepos:=0 ;printout(( "! Error: ", 
"unexpected module tag after a macro identifier"));error(2 ))),(IF ch/= "="THEN(
loc OF web>=LWB b OF web|loc OF web-:=1 )FI;(print(newline);consolepos:=0 ;
printout(( "! Error: ", "unexpected module tag in a macro header"));error(2 ))),
IF ch = "="THEN#7.4.1.6:# IF UPB mtag>3 THEN IF mtag[UPB mtag-2 :] = "..."THEN
 ADDMOD res =addmoduletag(moduleroot,mtag[:UPB mtag-3 ],FALSE,TRUE);CASE e OF
 res-1 IN BEGIN addmodtext(curmod:=mod OF res,maketext(sec OF web));curmood:=5 
END,(print(newline);consolepos:=0 ;printout(( "! Error: ", 
"unknown module prefix"));error(2 )),BEGIN STRING fn =searchwithfilenumber(
inctree,fnum OF mod OF res);(print(newline);consolepos:=0 ;printout(( 
"! Error: ", "prefix starts more than one module. The previously"+lf+ 
"defined module is in file "+fn+ " l."+whole(lnum OF mod OF res,0 )));error(2 ))
;curmood:=1 END ESAC ELSE#7.4.1.7:# curmood:=5 ;addmodtext(curmod:=mod OF
 addmoduletag(moduleroot,mtag,TRUE,FALSE),maketext(sec OF web))#:7.4.1.7# FI
 ELSE#7.4.1.7:# curmood:=5 ;addmodtext(curmod:=mod OF addmoduletag(moduleroot,
mtag,TRUE,FALSE),maketext(sec OF web))#:7.4.1.7# FI#:7.4.1.6# ELIF(loc OF web>=
LWB b OF web|loc OF web-:=1 );#7.4.1.8:# UPB mtag>3 THEN IF mtag[UPB mtag-2 :] =
 "..."THEN ADDMOD res =addmoduletag(moduleroot,mtag[:UPB mtag-3 ],FALSE,TRUE);
CASE e OF res-1 IN addmodtext(curmod,TEXT(mod OF res,notext)),(print(newline);
consolepos:=0 ;printout(( "! Error: ", "unknown module prefix"));error(2 )),
BEGIN STRING fn =searchwithfilenumber(inctree,fnum OF mod OF res);(print(newline
);consolepos:=0 ;printout(( "! Error: ", "module prefix "+mtag+ 
" is also a prefix of module defined"+lf+ "in file "+fn+ " l."+whole(lnum OF mod
 OF res,0 )));error(2 ));curmood:=1 END ESAC ELIF#7.4.1.9:# REF MODULE rm =mod
 OF addmoduletag(moduleroot,mtag,TRUE,FALSE);curmood =5 THEN addmodtext(curmod,
TEXT(rm,notext))ELIF curmood =4 THEN addmactext(curmac,TEXT(rm,notext))#:7.4.1.9
# FI ELIF#7.4.1.9:# REF MODULE rm =mod OF addmoduletag(moduleroot,mtag,TRUE,
FALSE);curmood =5 THEN addmodtext(curmod,TEXT(rm,notext))ELIF curmood =4 THEN
 addmactext(curmac,TEXT(rm,notext))#:7.4.1.9# #:7.4.1.8# FI,IF ch = "="THEN(
print(newline);consolepos:=0 ;printout(( "! Error: ", 
"unexpected module tag in a module body"));error(2 ))ELIF(loc OF web>=LWB b OF
 web|loc OF web-:=1 );#7.4.1.8:# UPB mtag>3 THEN IF mtag[UPB mtag-2 :] = "..."
THEN ADDMOD res =addmoduletag(moduleroot,mtag[:UPB mtag-3 ],FALSE,TRUE);CASE e
 OF res-1 IN addmodtext(curmod,TEXT(mod OF res,notext)),(print(newline);
consolepos:=0 ;printout(( "! Error: ", "unknown module prefix"));error(2 )),
BEGIN STRING fn =searchwithfilenumber(inctree,fnum OF mod OF res);(print(newline
);consolepos:=0 ;printout(( "! Error: ", "module prefix "+mtag+ 
" is also a prefix of module defined"+lf+ "in file "+fn+ " l."+whole(lnum OF mod
 OF res,0 )));error(2 ));curmood:=1 END ESAC ELIF#7.4.1.9:# REF MODULE rm =mod
 OF addmoduletag(moduleroot,mtag,TRUE,FALSE);curmood =5 THEN addmodtext(curmod,
TEXT(rm,notext))ELIF curmood =4 THEN addmactext(curmac,TEXT(rm,notext))#:7.4.1.9
# FI ELIF#7.4.1.9:# REF MODULE rm =mod OF addmoduletag(moduleroot,mtag,TRUE,
FALSE);curmood =5 THEN addmodtext(curmod,TEXT(rm,notext))ELIF curmood =4 THEN
 addmactext(curmac,TEXT(rm,notext))#:7.4.1.9# #:7.4.1.8# FI ESAC#:7.4.1.5# ,#
7.4.1.4:# IF curmood =4 THEN addmactext(curmac,TEXT(STRING( "@"),notext))ELIF
 curmood =5 THEN addmodtext(curmod,TEXT(STRING( "@"),notext))FI#:7.4.1.4# ,BEGIN
 curmod:=unnamedmodule;curmood:=5 ;addmodtext(curmod,maketext((sec OF web)))END,
BEGIN curmac:=nomac;oneoffmacro:=TRUE;curmood:=2 END,#7.4.1.10:# IF STRING incfn
 =gathertocs( ">");scanincludedtree(inctree,incfn)THEN(print(newline);consolepos
:=0 ;printout( "! Warning: included file "+incfn+ " already included");error(1 )
);curmood:=1 ELIF NOT addincludefile(web,incfn)THEN(print(newline);consolepos:=
0 ;printout(( "! Error: ", "cannot find the included file "+incfn));error(2 ));
curmood:=1 ELSE curmood:=1 FI#:7.4.1.10# ,BEGIN curmac:=nomac;oneoffmacro:=FALSE
;curmood:=2 END,IF curmood =4 THEN addmactext(curmac,TEXT(0 ,notext))ELIF
 curmood =5 THEN addmodtext(curmod,TEXT(0 ,notext))FI#:7.4.1.3# OUT(print(
newline);consolepos:=0 ;printout(( "! Error: ", "unknown control sequence"));
error(2 ));curmood:=1 ESAC#:7.4.1.2# ,(STRING s):#7.3.1.4:# CASE curmood IN SKIP
,IF s = "("THEN#7.3.1.5:# IF curmac IS nomac THEN(print(newline);consolepos:=0 ;
printout(( "! Error: ", "macro identifier missing"));error(2 ));curmood:=1 ELIF
 param OF curmac ISNT nowparam THEN(print(newline);consolepos:=0 ;printout(( 
"! Error: ", "unexpected character following a macro formal parameter"));error(
2 ));curmood:=1 ELSE curmood:=3 FI#:7.3.1.5# ELIF s = "="THEN#7.3.1.6:# IF
 curmac IS nomac THEN(print(newline);consolepos:=0 ;printout(( "! Error: ", 
"missing macro id"));error(2 ));curmood:=1 ELSE curmood:=4 FI#:7.3.1.6# ELSE(
print(newline);consolepos:=0 ;printout(( "! Error: ", 
"unexpected string in macro id"));error(2 ));curmood:=1 FI,IF s = ","OR s = ")"
THEN SKIP ELIF s = "="THEN curmood:=4 ELSE(print(newline);consolepos:=0 ;
printout(( "! Error: ", "unexpected string in macro header"));error(2 ));curmood
:=1 FI,addmactext(curmac,TEXT(curtok,notext)),addmodtext(curmod,TEXT(curtok,
notext))ESAC#:7.3.1.4# ,(REF TAG tag):#7.3.1.8:# CASE curmood IN SKIP,IF curmac
 IS nomac THEN IF ADDMAC res =addmacroid(macroroot,addtag(tagroot,tag),
oneoffmacro);e OF res =1 THEN STRING fn =searchwithfilenumber(inctree,fnum OF
 mac OF res);(print(newline);consolepos:=0 ;printout(( "! Error: ", 
"macro identifier already defined in file "+fn+ " l."+whole(lnum OF mac OF res,
0 )));error(2 ));curmood:=1 ELSE curmac:=mac OF res FI ELSE(print(newline);
consolepos:=0 ;printout(( "! Error: ", "macro id. already read"));error(2 ));
curmood:=1 FI,IF NOT addmacropar(curmac,addtag(tagroot,tag))THEN(print(newline);
consolepos:=0 ;printout(( "! Error: ", "duplicate macro formal parameter"));
error(2 ));curmood:=1 FI,BEGIN REF TAG storedtag =addtag(tagroot,tag);REF MACRO
 rm =searchmacro(macroroot,storedtag);addmactext(curmac,TEXT((rm:=:nomac|
storedtag|rm),notext))END,BEGIN REF TAG storedtag =addtag(tagroot,tag);REF MACRO
 rm =searchmacro(macroroot,storedtag);addmodtext(curmod,TEXT((rm:=:nomac|
storedtag|rm),notext))END ESAC#:7.3.1.8# OUT addmodtext(unnamedmodule,TEXT(
curtok,notext));#6.1.1.4:# IF history>1 THEN print((newline, 
"! Did we find something wrong?",newline));#8.1.1.3:# IF upb OF output>0 THEN
 put(f OF output,((b OF output)[:upb OF output],newline))FI;close(f OF output)#:
8.1.1.3# ;exit(5 )ELSE SKIP FI;phaseone:=FALSE;#8.3.1.1:# processmodule(output,
unnamedmodule,HEAP[4 ]INT)#:8.3.1.1# ;#8.1.1.3:# IF upb OF output>0 THEN put(f
 OF output,((b OF output)[:upb OF output],newline))FI;close(f OF output)#:
8.1.1.3# ;exit(0 )#:6.1.1.4# ESAC#:7.3.1.3# OD END FINISH#:6.1.1.2# 

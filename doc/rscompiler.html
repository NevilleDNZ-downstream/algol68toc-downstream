<html lang="en">
<head>
<title>The RS Compiler for ALGOL 68</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="The RS Compiler for ALGOL 68">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">The RS Compiler for ALGOL 68</h1>
<h2 class="chapter"><a name="TOC0"></a>1 Introduction</h2>

<p>The RS compiler differs from most others in producing output which
bears very little resemblance to machine code.  The structure of the
output is close to that of Algol 68 in many respects, and yet the work
done by the compiler is not insubstantial.  It checks the correctness
of the source text, as far as this is possible by syntax and mode
analysis.  If an error is found, it outputs the diagnosis; otherwise
the information in the source program is recast in a form suitable for
translation.  Complicated operations are broken down into sequences
of the simpler steps adjudged primitive for the purpose of code
generation.  For example, as the modes of all objects in the source
program have been determined by the compiler, it can specify every
coercion explicitly.  The coercions will in fact make their appearance
to the translator at the precise moments required, even though the
compiler may have had to see much farther ahead in the program to
determine the destination mode.  This is one of the fruits of the
technique of using the output from the compiler as a buffer for the
re-ordering of information.  The compiler puts its output on one or
another of several parallel streams, and arranges that the item
immediately required by the translator is always at the reading point
on one of the streams.  This technique, reported by Currie to be
widely used by compiler writers at the University of Grenoble,
explains why we use the term stream language for the compiler's
output.

<pre class="example">                         ^
                         |
              1st pass   |                          2nd pass
             |________________|________|           |___________|
             |      faults    |        |  streams  |           |
             |                |        |           |           |  object
             |______|_________| output |&gt;-&gt;-&gt;-&gt;-&gt;-&gt;|           |   code
     source  |      |         |        |&gt;-&gt;-&gt;-&gt;-&gt;-&gt;| translate |---------&gt;
      text   |      | compile |        |&gt;-&gt;-&gt;-&gt;-&gt;-&gt;|           |
     -------&gt;|input |         |        |           |           |
             |      |__________________|           |           |
             |      | specifications   |           |           |
             |      |                  |           |           |
             ______________^____________           ____^___^____
                           |                           |   |
                           |                           |   |
                           |                           |   |
               |______________________|                |   |
               |      library of      |&lt;----updates ---'   |
               |   compiled modules   |&lt;--- assembly ------'
               |                      |
               ________________________
</pre>
   <p>In any Algol 68 system based on the RS compiler, the first pass
compiles source text into stream language and the second pass - which
must be a genuinely distinct pass - translates stream language into
machine code.  Although the compiler is machine independent, this
attribute cannot extend to the whole of the first pass, whose input
and output arrangements will depend on hardware.  For each new
implementation, therefore, it is necessary not only to write a
translator, but also to write a new interfacing shell for the
compiler.  The Figure shows the whole system diagramatically,
including the library of compiled modules which will provide for the
Algol 68 standard prelude and for users' own collections (&ldquo;albums&rdquo; in
Algol 68-R).  To give it the necessary interfaces, the compiler is
written as a procedure, with parameters for the shell.

<h3 class="section"><a name="TOC1"></a>1.1 The Source Language</h3>

<p>The language accepted by the compiler is Algol 68 as defined in the
Revised Report with some deviations, principally that modes and
identifiers must be declared before they are used.  There are
restrictions on the use of <code>LONG</code> and <code>SHORT</code> (see Appendix 2).  Arrays
are not copied in identity declarations and in the corresponding
parameter situations.  The handling of flexible arrays differs from
the report in that flexibility propagates through a mode to the right
(ie inwards).  The use of transient references is not checked.  These
are the main deviations.  There are also some significant extensions
to Algol 68 which influence the design of a translator.  Two new types
of data structure have been added to the language, mainly to increase
efficiency in critical applications such as data processing and
compiler writing.  Other extensions have been introduced in the light
of experience to provide flexibility in system programming work.  Most
extensions can be concealed from the ordinary user by restricting the
generally available documentation.  But they cannot be concealed from
the translator writer, who may wish to exploit them and must, in any
case, be able to translate their stream language images into machine
code.  The various extensions are described in Appendix 4.

<h2 class="chapter"><a name="TOC2"></a>2 Stream Language Output</h2>

<p>Stream language consists of a sequence of commands ("imperatives")
which are generated by the compiler one at a time.  One of the
parameters supplied to the compile procedure is a procedure used for
the output of stream language.  It has a parameter of mode <code>OUTPUT</code>;
this is a union which decomposes into one of a number of more
specialised modes, each corresponding to one class of imperative, such
as the class of all declarations.  There is one special imperative, in
a class by itself, which can be disposed of immediately.  This tells
the translator when to switch its reader from one stream to another. 
After the stream collation has taken place, the translator sees stream
language as one single unbranching series of imperatives, and
throughout the remainder of Part A, this is exactly how we shall look
at it.

<h3 class="section"><a name="TOC3"></a>2.1 The Structure Of Stream Language</h3>

<p>Stream language defines objects and operations to produce further
objects.  The operations arise from the operators of Algol 68, from
coercions and from operations such as assignment.  Operands are loaded
on to a conceptual reverse Polish stack before the operator is
specified.  The other facet of stream language is control structure,
which is shaped in terms of phrases, serial clauses and closed
clauses, like Algol 68 itself.  Clauses always deliver objects, which
may possibly be void, and serial clauses determine localities in the
usual technical sense.  However, in spite of the resemblance to Algol
68, if the source text and compiled versions of a particular program
are compared, the various structural units will not be found in exact
one-to-one correspondence.  In its conversion of formulae to reverse
Polish form, the compiler will have removed binding brackets (though
not when the enclosure is a serial clause with semi-colons), and it
may have introduced extra phrases as a consequence of breaking down
complicated operations into successions of more primitive ones.

   <p>The actual imperatives which impart to stream language its phrase
structure reflect familiar symbols of Algol 68.  These imperatives all
belong to the mode <code>OUTPUT(XCONTROL)</code>.  (Here we are using the notation
<code>X(Y)</code> to serve as a reminder that <code>Y</code>, the mode under consideration, is a
constituent of a union <code>X</code>.)  The Mode <code>XCONTROL</code> is a structure whose
function is indicated in its principal field by one of the following
mnemonic integer values.

   <p><code>
    xbegin, xsemi, xexit, xend, xroutinend,
    xcoll, xcollcomma, xendcoll,
    xif, xthen, xelse, xfi,
    xcase, xin, xcomma, xout, xesac,
    xcaseu, xinu, xuchoice, xcommau, xoutu, xesacu,
    xfor, xforall, xwhile, xdo, xod,
    xfinish
</code>

   <p>The meanings should for the most part be obvious.  Note that
xroutinend has no counterpart in Algol 68; it occurs immediately after
the end of a routine text.  Note also that the compiler always
distinguishes between different types of closed clause by supplying
the appropriate bracket, eg xcoll to open a collateral but xbegin for
an ordinary closed clause, xcaseu for a conformity clause but xcase
for an ordinary case clause.        Other fields of an <code>XCONTROL</code> contain
various items of supplementary information.  Whenever the <code>XCONTROL</code>
initiates a serial clause or a closed clause, the mode of the result
to be delivered is given.  At the start of a serial clause, a
property word in the <code>XCONTROL</code> contains bits which show whether the
serial clause contains a semi-colon, an <code>EXIT</code>, a label setting,
variable declaration etc.  Special bits are also present in all
relevant imperatives to assist the translator with dynamic storage
control.

   <p>We have described <code>XCONTROL</code> first because it is where a top-down
examination of stream language should begin.  It is also where the
structure of Algol 68 shows through most clearly.  The <code>OUTPUT</code> union
does in fact include quite a large number of modes, of which the
five most important are

     <dl>
<dt><code>XCONTROL</code><dd>control indication

     <br><dt><code>XDEC</code><dd>declaration of identifier or label

     <br><dt><code>XLOAD</code><dd>load of operand

     <br><dt><code>XOPER</code><dd>operation

     <br><dt><code>XROUTINE</code><dd>routine text
</dl>

   <p>The mode <code>XDEC</code> is itself a union of <code>XIDDEC</code> and <code>XLABDEC</code>.  An imperative
of the latter mode is a label declaration, introduced by the compiler
at the beginning of the serial clause containing the actual label
setting - which is indicated by another form of <code>XLABDEC</code> imperative. 
Thus, in stream language, labels are always declared before they
are used.  The mode <code>XDEC(XIDDEC)</code> corresponds to those Algol 68
declarations which define identifiers, except that the shortened
forms of procedure and operator declarations are handled by <code>XROUTINE</code>
imperatives.  Any occurrence of a routine text in the source program
gives rise to an <code>XROUTINE</code> imperative, which can be thought of as a
declaration in stream language, whether or not it came from a
declaration in the source-text.  A full identity declaration in the
source program, whether for a procedure or any other object, always
becomes an <code>XDEC(XIDDEC)</code> imperative.  So also does a variable
declaration or any operator declaration of the unshortened variety. 
Priority declarations are absorbed by the compiler and used when
converting expressions into reverse Polish.

   <p>There are no mode declarations in stream language to correspond with
those in the source text of a program, though in a sense every mode
used in a program is declared in stream language.  At the outset of
the collated stream, one imperative supplies the translator with a
vector containing information about all the modes used in the program. 
Thereafter, any one of these can be represented as an index to the
vector.

   <p>For compactness and simplicity, all cross-referencing in stream
language is done by integers.  Declarations are all numbered.  Source
text names are passed across by the compiler in stream language
declarations only to enable a translator to use them in run-time
diagnostic messages.  The real stream language identifiers are the
declaration numbers, of which there are three separate sets - one for
<code>XLABDEC</code>, one for <code>XIDDEC</code> and one for <code>XROUTINE</code> declarations. 
The <code>XIDDEC</code>
numbers are re-used for declarations whose ranges do not overlap. 
This keeps to a minimum the amount of information the translator holds
about identifiers, assuming that it organises its information in the
obvious manner.

   <p>There is a special imperative at the beginning of a stream language
program which tells the translator the sizes required for its various
vectors.

<h3 class="section"><a name="TOC4"></a>2.2 The Reverse Polish Stack</h3>

<p>In the present account of stream language, the reverse Polish stack is
a purely conceptual device for remembering operands, and at this
conceptual level, the loading of an operand does not imply action of
any other kind.  In reality, most translators will find it convenient
to maintain a real stack in some form or other, to act as a kind of
work-bench for the generation of code.  However, the way in which
operands would be represented on an actual translator stack lies
wholly within the province of the translator designer, and is not
discussed in this section.

   <p>Operands appear on the reverse Polish stack in two ways.  They may
have been placed there as a result of a previous operation, or they
may be introduced by an <code>OUTPUT(XLOAD)</code> Imperative.  The mode <code>XLOAD</code> is a
union whose various constituent modes describe the different forms
of object which can be loaded.  For example, <code>XLOAD(INT)</code> loads a
declaration number standing for some object which has previously been
declared.  Other modes in <code>XLOAD</code> introduce undeclared objects, such as
those expressed in the Algol 68 program as denotations.

   <p>Almost every kind of object in stream language is described by its
Algol 68 mode represented as an integer item of data - not to be
confused with the mode of the imperative which handles it.  To the
compiler, the mode of an object is important as a means of checking
program consistency and selecting operator definitions correctly; to
the translator its main importance is in determining the size of an
object in the running machine.  This is of course impossible for an
Algol 68 array or vector, as the number of elements is unknown at
compile time.  However, in addition to elements, every array has a
descriptor of fixed size, and in stream language it is the descriptor
which is taken as the object to which an array mode applies.  This is
not to deny that array elements exist!  Certain <code>XOPER</code> imperatives call
for production of code to find space for array elements in the object
machine, and to copy them from one place to another, and yet a set of
array elements is never a reverse Polish operand.  This is because the
translator can obtain all the information it needs about an array from
the descriptor.  We may therefore conclude that stream language only
operates directly on objects of known size.  As we shall show, this is
the very feature of its design which enables it to break down
complicated declarations, generators and assignments into the
rudimentary steps which a translator can handle easily.

<h3 class="section"><a name="TOC5"></a>2.3 The Creation Of New Objects</h3>

<p>The work entailed in creating a new object is split between compiler
and translator, the compiler doing as much as it can without knowing
anything about the final object machine.  It cannot do very much with
source text denotations, as the translator must deal with machine
representations.  Denotations are therefore passed into stream
language almost literally, in <code>XLOAD</code> imperatives, though number
denotations are tidied up into standard formats.  Routine texts are
compiled like any other pieces of Algol 68, with formal parameters
expressed by <code>XIDDEC</code> imperatives of type <code>XFDEC</code> the whole routine
being preceded by an <code>XROUTINE</code> imperative which gives it a declaration
number in every case.

   <p>Jumps are treated as objects in stream language, and loaded by their
label declaration numbers.  No action is taken until specified by a
subsequent coercion (an <code>XOPER</code>).

   <p>In Algol 68, a reference is created by a generator or a variable
declaration; its purpose is allocation of storage space for an object
of given mode.  The object can be described as `simple' if the
generator or declaration contains no array bounds, for then the total
amount of space is known from the mode, and stream language does no
more than reflect the Algol 68 constructions.  A generator becomes an
<code>XLOAD(XGEN)</code> imperative, which puts a new local or heap reference on
the reverse Polish stack, and a variable declaration becomes an
<code>XDEC(XIDDEC)</code> of type <code>XVARDEC</code>, or <code>Xivardec</code> if the declaration is
combined with an initial assignment.  Either type creates a new
reference and gives it a declaration number.  In addition, <code>XIVARDEC</code>
will find the object for initial assignment on the reverse Polish
stack, and remove it.  Being a declaration and not an operator, it
leaves no result behind.

   <p>When the Algol 68 generator contains array bounds, space for elements
has to be generated dynamically.  As these may introduce further
arrays, the task can be a protracted one.  The compiler breaks it
down so that the translator is never called upon to deal with more
than one array at a time.  As an example at one level only, consider
the declaration
<pre class="example">         [1 : n] REAL r;
</pre>
   <p>which requires the translator to
     <ul>
<li>generate space dynamically for n reals,

     <li>create the associated fixed size object (ie the descriptor) of mode <code>[] REAL</code>,

     <li>create an object of mode <code>REF [] REAL</code> and assign the descriptor to it (a `static' assignment). 
</ul>

   <p>In outline (for the compiler actually does a little more), this maps
into stream language as

     <dl>
<dt><code>XLOAD</code> the lower bound 1<dt><code>XLOAD</code> the upper bound <var>n</var><dt><code>XOPER xbdpack</code><dd>packs the bounds into a single object

     <br><dt><code>XLOAD</code> a boolean for local/heap, here local<dt><code>XOPER dyngrab</code><dd>takes the boundpack and boolean operands, generates space for array elements and delivers the descriptor

     <br><dt><code>XDEC(XIDDEC) xivardec</code><dd>creates the variable, gives it a declaration number, takes
         the descriptor from the reverse Polish stack as operand and
         assigns it statically to the array variable
</dl>

   <p>It is particularly to be noticed that an <code>xivardec</code> initialisation is
always a static assignment, ie assignment of a fixed size stream
language object only, with no regard for any array elements. 
Normally, <code>xivardec</code>s are used when there are initial assignments in the
source text (eg <code>REAL X := 0.0</code>), but not if the object declared is an
array variable.  Initial assignment of array elements is carried out
separately as a standard assignment operation, described in A2.4.  An
array generator gives the same sequence as that shown for an array
declaration, except that the <code>XIDDEC xivardec</code> is replaced by the
<code>XOPER statgrab</code>.  Instead of creating a reference and then declaring
it as a variable, statgrab creates the reference but puts it on the
reverse Polish stack after statically assigning the descriptor.

   <p>In actuality, all but the final step shown above is wrapped up in a
stream language routine invented by the compiler for the given mode. 
In the example, the routine would deliver the <code>[] REAL</code> as operand for
the <code>xivardec</code>.  In a more general case, eg from the source declaration
<pre class="example">         STRUCT (BOOL b, [1 : n] REAL r) s;
</pre>
   <p>the routine would deliver the fixed-size object of mode
<pre class="example">         STRUCT (BOOL b, [] REAL r)
</pre>
   <p>as operand for the <code>ivardec</code>.

   <p>For declarations involving array space at more than one `depth', the
routine for the whole array mode calls similar routines for any
contained array modes.  For example, consider the source declaration
<pre class="example">         [1 : m] STRUCT (BOOL b, [1 : n] REAL r) t;
</pre>
   <p>The mode already considered is now contained in an array, and the
inner routine (<code>nr</code>, say) will deliver the <code>STRUCT (BOOL b, [] REAL r)</code>
inside the routine (<code>mr</code>, say) for the whole mode, where it will be
assigned to each of the <var>m</var> array elements - as <var>m</var> fixed size objects. 
The routine <code>mr</code> will finally deliver the fixed size object
<pre class="example">         [] STRUCT (BOOL b, [] REAL r)
</pre>
   <p>for assignment to <code>t</code> in the <code>ivardec</code>.

<h3 class="section"><a name="TOC6"></a>2.4 Assignment</h3>

<p>The <code>XOPER xassign</code> takes two operands, a destination and a source. 
It leaves the first operand on the reverse Polish stack at the
conclusion of the assignment, clearly imaging the Algol 68
construction.  But the stream language operation gives the translator
less work than would an Algol 68 assignment in its full generality. 
As with complicated declarations, the compiler invents and calls
specially tailored routines to break down complicated assignments.

   <p>The mode of the destination determines what <code>xassign</code> is called upon to
do.  If it is a ref vector or ref array (non flexible), the actual
elements are to be copied and the associated descriptors left
untouched.  This is `dynamic assignment'.  For every other destination
mode, including ref flex array and ref flex vector, <code>xassign</code> means
static assignment.  The object to be copied is the stream language
source operand, which may be a descriptor but cannot be a set of
elements.  From a stream language point of view, dynamic assignment is
the oddity, as the operands are not the objects directly involved in
the copying process.  The translator's generation of code to copy
array elements is a kind of side-effect to an otherwise inert stream
language operation.  At this point, it is worth recalling the
initialised variable declaration of A2.3, as the assignment embodied
in the <code>xivardec</code> is always of the static type, irrespective of mode. 
It is not an absorbed xassign operation.

   <p>In a dynamic assignment, the elements to be copied will always be
objects of known size.  The translator is never asked, all in one go,
to copy elements which themselves contain elements to be copied.  The
invented assignment routines see to that; by the use of "forall"
constructions, all the loops are given explicitly.

   <p>One further operation is required to complete the subject of
assignment.  An Algol 68 assignment to a flexible array or vector
variable implies the making of a new set of elements and a new
descriptor, and the xassign in this case deals only with the
descriptor.  A special operation <code>xcopy</code> always precedes the static
assignment to a flex variable.  This operation takes the descriptor
from the right-hand side of the Algol 68 assignment as its one
operand, generates the required amount of space (on the heap) for a
new copy of the elements, copies the elements, constructs a new
descriptor and delivers this as the result of the operation.  The
<code>xassign</code> operation then picks up this new descriptor and statically
assigns it to the flex variable as already described.

<h2 class="chapter"><a name="TOC7"></a>3 Implementation</h2>

<p>To harness the RS compiler for use on a new machine, the obvious need
is the translator to convert stream language into machine code, but
one must never lose sight of the fact that the final product is a
system and not just a collection of programs.  The importance of the
shell for the compiler is obvious from the Figure in section A1, a
major part of which is concerned with the updating and retrieval
scheme for library modules.  Not least in importance here is the
actual content of the system library, including transput.  Finally,
proper provision must be made for run-time diagnostics, not shown in
the Figure but clearly a crucial part of the system.

   <p>The development of a system initially depends of the process known as
bootstrapping, and we conclude with an outline of its three stages.

   <p>Stage 1 begins with getting the compiler running on some machine,
which will normally be different from the target machine.  Since the
RS compiler is written in its own language, the simplest method is to
use an existing RS implementation, although there is nothing to
prevent the use of some other machine for bootstrapping provided that
the compiler is suitably adapted.  With a temporary first pass
actually running, the next phase of stage 1 is to produce a matching
translator which generates code for the final object machine.  It may
be convenient to write this translator in the bootstrapping machine
using the same language as the compiler.  Alternatively, it can be
written for the new machine from the start, provided that the new
machine supports a suitable high-level language.  Either way we are
now equipped with a means of producing code for the new machine from
Algol 68 source text.

   <p>Stage 2 uses the result of stage 1 to compile and translate a final
version of the compiler and a shell suitable for the new machine.  The
translator is also compiled and translated when the first of the two
plans is adopted.  The result of stage 2 is a compiler, shell and
translator which can be loaded in the new machine.

   <p>Stage 3 consists of tidying up.  The translator probably requires
enhancement, for up to this point it has only had to deal with the
system itself, which is almost certainly in a subset of stream
language.  The RS compiler produces a subset, and the other parts
of the system can with advantage do the same.  Now the compiler and
translator should be compiled and translated in the new machine to
check that the whole system is self-supporting.  This may entail
rewriting the translator, for if the second plan was adopted, it will
probably not have been written in Algol 68.

<!-- ********************************************************************* -->
<!-- PART B   SINGLE MODULE COMPILATION -->
<!-- ********************************************************************* -->
<h2 class="chapter"><a name="TOC8"></a>4 The Compiler Shell</h2>

<p>The &ldquo;compile&rdquo; procedure is specified as follows:
<pre class="example">     PROC  compile  =
     ( PROC (REF VECTOR [] CHAR, REF INT) BOOL  input,
       PROC (OUTPUT, INT) VOID  output,
       PROC (VECTOR [] CHAR, INT) VOID  fault,
       PROC (INT) REF VECTOR [] CHAR  message,
       PROC (ID, INT, BOOL) YMODINFO  give module details,
       PROC (ID, ID, YM) YSPEC  give spec,
       PROC (REF VECTOR [] CHAR, BOOL) INT  lookup,
       REF [] STRUCT(INT type, value)  charset
     ) BOOL:
</pre>
   <p>This procedure must be called in pass 1 with actual parameters written
to suit the translator and the hardware in which the system is to run. 
These actual parameters constitute the `shell' of pass 1 (see Figure
in A1).

   <p>The procedures <code>give module details</code> and <code>give spec</code> are concerned
with inter-module checking and are described in Part C.  The
remaining parameters are dealt with in this present chapter.

   <p>Most one-dimensional arrays in the RS compiler have lower bound 1, so
they have been written as vectors, which are normally more efficient
than arrays.  Since the same will be true of most translators, vectors
are used in the interface wherever possible.  One-dimensional arrays
may be used throughout if desired.

<h3 class="section"><a name="TOC9"></a>4.1 Input Of Source Text</h3>

<p>Source text is input by the procedure
<pre class="example">     PROC input = (REF VECTOR [] CHAR source, REF INT size) BOOL:
</pre>
   <p>which is called by the compiler.  In <code>source</code>, the compiler provides
space for <code>linesize</code> characters of text (see Appendix 5).  The input
procedure must put a line of text into this space and give the actual
number of characters in <code>size</code>.  Blank lines are allowed.  The
procedure must ordinarily deliver <code>TRUE</code>, but must deliver <code>FALSE</code> if
nothing has been supplied in <code>source</code> because there were no more lines
of text for the compilation.  A suitable amount of source text must be
retained by the input procedure for output by the fault procedure
(B1.5) when required.

   <p>The compiler's first task is to assemble characters into the larger
entities, such as identifiers, required for syntax analysis.  It has
no knowledge of the character set or representations of symbols, and
all such information has to be made available through its parameters
<code>charset</code> and <code>lookup</code>.  These are described in sections B1.2 and
B1.4.

<h3 class="section"><a name="TOC10"></a>4.2 The <code>charset</code> Parameter</h3>

<p>The <code>charset</code> parameter is an array such that <code>charset[i]</code> describes the
properties of the character whose <code>ABS</code> value is <code>i</code>.  Each element of the
array has a type field and a value field, which must be filled in
according to certain fixed conventions.  For the compiler to assemble
identifiers, it needs to know which characters are the letters, which
the digits and which the space character.  This is because identifiers
must start with a letter and continue with letters or digits, with
spaces ignored; the identifier is thus terminated by the first
non-letter non-digit character encountered.  The letters a to z must
all be given type 3 and values 10 to 35 respectively.  The digits 0-9
are given type 4 and values 0-9.  The space character is given type 2
and value 37.  If there are any further alphabetic characters besides
a to z needed in identifiers, such as accented letters, they must
be given type 3 and value 36, and cannot be used other than in
identifiers.

   <p>Bold symbols are assembled by the compiler in one of two ways.  If the
character set contains only one alphabet, a `stropping' scheme must be
adopted, and this can take two forms.  In `single' stropping, the bold
symbol is simply prefixed by a strop character, whilst in "matched"
stropping it is enclosed in a pair of identical strop characters. 
Aside from the strop characters, the form of a bold symbol is exactly
similar to that of an identifier, except that spaces are not allowed. 
When single stropping is used, the strop character is specified as
type 7 and the bold symbol terminates in front of a character, such
as space, which cannot be a legal continuation of the symbol.  When
matched stropping is used, the strop character if specified as type 8,
and the bold symbol terminates in the same way except that the
compiler checks that the terminator is the strop character and moves
past it.  (If it is not, the fault procedure is called.)  The value
field for the strop character can be set to 100 if the character is
not to be used for any other purpose.  Provided that reasonable
discretion is used, the strop character can be made to do double
duty and serve as a symbol in its own right, such as the decimal
point symbol.  The value field would then be filled in to indicate
the required meaning as described in B1.3.

   <p>If a second alphabet is available in the character set, it can be
defined to be the bold alphabet, and there will be no need to define
a strop character.  Bold letters must be given type 6 and the value
field set to the negative number <code>-(n + 1)</code>, where <code>n</code> is the
<code>ABS</code> either
of the bold letter itself, which we shall describe as a `direct
value' or of the corresponding ordinary letter (`indirect value'). 
The choice, which must be the same throughout the alphabet, is
governed by the way the lookup table for bold symbols is to be
organised, as discussed later.

   <p>The character used as the quote symbol must be given type 5 and value
100, which debars it for any other purpose except inside comment or,
doubled, inside string or character denotations.  If there are any
characters whose use is to be restricted solely to the insides of
strings or comment, these must be given type 1 and value 100 (`illegal
representation').

   <p>Once the characters of types 1 to 8 have been dealt with as described
above, all the remaining characters are available, singly or in
combination, to represent symbols.  A character which never combines
is given type 20, while a character which can occur as part of a
compound symbol is given type 21, 22 or 23 according to the positions
it is allowed to occupy.  These are shown in the table set out below. 
Characters which can be used in compound symbols may be used singly as
well (for consider &lsquo;<samp><span class="samp">:</span></samp>&rsquo;, &lsquo;<samp><span class="samp">=</span></samp>&rsquo; and &lsquo;<samp><span class="samp">:=)</span></samp>&rsquo;.  The value field in charset
is normally used to specify the meaning of the character when it is
used as a single-character symbol (but see B1.3 for a possible
exception to this rule).

   <p>When the compiler encounters a character which may be the start of a
compound symbol, it always tries to complete the symbol and terminates
only when further continuation is impossible.  It is therefore
advisable that all monadic operators be represented by characters of
types 20 or 21, as this enables consecutive monadic operators to be
used in a program without space separation.  To see this, consider a
pair of monadic operators such as &lsquo;<samp><span class="samp">+-</span></samp>&rsquo;.  If the minus can only occur
alone or at the very beginning of a compound symbol, it cannot be the
second character of a compound symbol starting &lsquo;<samp><span class="samp">+-</span></samp>&rsquo;.  A space between
the plus and minus is therefore unnecessary.

   <p>In the assembly of identifiers, bold symbols, string denotations,
numbers and compound symbols, the end of a line will always terminate
an item.  If a string denotation is to extend over more than one line,
a quote symbol must be given at the end of each line and the next
line introduced by a further quote.

   <p>If an implementation is to accept both upper/lower case programs and
programs written using a stropping convention, the shell must convert
one representation to the other.

   <p>The field settings for <code>charset</code> are as follows (a value of 100 means &lsquo;<samp><span class="samp">invalid
representation</span></samp>&rsquo;).

     <dl>
<dt><var>type</var><dd><code>meaning of type (value)</code>

     <br><dt>1<dd>character which can only be used inside strings or comment (100)
<br><dt>2<dd>space (37)
<br><dt>3<dd>letter, for use in identifiers, labels and field selectors
(a to z (10-35), any others (36))
<br><dt>4<dd>digit (0-9)
<br><dt>5<dd>string quote (100)
<br><dt>6<dd>bold letter (see B1.2)
<br><dt>7<dd>single stropping character (see B1.2)
<br><dt>8<dd>matched stropping character (see B1.2)
<br><dt>20<dd>non-combining character (see B1.3)
<br><dt>21<dd>character which, when used in combination, can only be the first character of the compound symbol (see B1.3)
<br><dt>22<dd>character which can be used anywhere in a compound symbol (see B1.3)
<br><dt>23<dd>character which, when used in combination, can only be the last character of the compound symbol (see B1.3)
</dl>

<h3 class="section"><a name="TOC11"></a>4.3 Values Of Symbols</h3>

<p>The compiler assumes nothing about the way modes, operators or
any other language symbols are to be represented in programs; it
understands the meanings of symbols in terms of its own fixed integer
values.  From the `type' information given in charset, it can assemble
single and multiple character symbols, but cannot convert them into
values by itself.  The shell writer must therefore decide on the
desired character representations for all the symbols listed in
Appendix 1, and make arrangements for supplying the corresponding
integer values to the compiler.  (Appendix 1 includes symbols for all
of the operators of the standard prelude, which are handled by the
compiler rather than the library system.)  The representations for
symbols can be single characters, bold symbols or compound symbols. 
The value fields for characters with types less than 20 have already
been laid down in B1.2.  The values for all compound symbols or bold
symbols - some of which might consist of a single bold letter - must
be embodied in a special lookup table as described in B1.4.

   <p>The values for the single character symbols of types 20-23 are
normally put into the value fields of the charset array.  The reason
for this is simply to optimise by reducing the number of calls of the
lookup procedure - in principle all symbols could have been treated
alike and included in one table.  The optimisation may be overridden
by giving such characters the value 99; this causes the lookup
procedure to be called as for compound and bold symbols.

   <p>The input system as a whole has great flexibility.  The shell writer
can choose whatever representations for symbols seem desirable,
although he is expected to include those given in Appendix 1, which
are taken from the Algol 68 report.  He may supplement the suggested
representations with alternative forms for the same symbol (for
instance, <code>&amp;</code> as alternative for <code>AND</code>).  And he can effectively subset
the language giving any unwanted symbol (eg <code>#</code>) the value 100 (`illegal
representation').

<h3 class="section"><a name="TOC12"></a>4.4 The Lookup Procedure</h3>

<p>When the compiler has assembled a bold or compound symbol, it calls
the shell procedure
<pre class="example">     PROC lookup = (REF VECTOR [] CHAR symbol, BOOL bold) INT:
</pre>
   <p>The parameter <code>symbol</code> will provide the actual characters of the
symbol, and incidentally must not be assigned to in the body of
<code>lookup</code>.  The parameter <code>bold</code> will be <code>TRUE</code> for bold and <code>FALSE</code> for
compound symbols.  The procedure must look up the symbol in its lookup
table, and deliver the integer value which can be found from Appendix
1.  Depending on how the lookup table is organised, the information as
to whether the symbol is bold or compound may help in minimising
search time.

   <p>Bold symbols represented in source text by single or matched stropping
are served up in the <code>symbol</code> parameter without the strop characters,
and will look just like unspaced identifiers.  Where a bold alphabet
is in use, the <code>symbol</code> parameter will use bold letters if their
values in charset were chosen to be "direct" (as defined in B1.2), but
will use ordinary letters if they were "indirect".  The choice of
direct versus indirect depends on the environment in which the RS
system is to be implemented.  Where some users' programs can use a
bold alphabet and others must use stropping, the indirect system has
advantages in ensuring a uniform way of keeping symbols in a library. 
However, in an environment where stropping need never be used at all,
the direct system has the advantage that it does not transform the
alphabet unnecessarily.

<h3 class="section"><a name="TOC13"></a>4.5 Output Of Fault Messages</h3>

<p>The <code>fault</code> procedure deals with output of compile-time error
messages.  The <code>VECTOR [] CHAR</code> parameter contains the diagnostic
message and the INT is the character position in the input text.  The
purpose of "fault" is to output the message in a presentable form,
preferably with an extract of the source text indicating the location
of the error.

   <p>Since the compiler generally avoids the use of strings in its
source-text, names and messages have to be introduced by means of its
<code>message</code> parameter.  This is a procedure that delivers a reference
to a particular string when given an integer parameter.  The strings
must be supplied by the shell writer as defined at the front of the
compiler.  The character &lsquo;<samp><span class="samp">%</span></samp>&rsquo; means that the following word should
appear in upper case, while &lsquo;<samp><span class="samp">.</span></samp>&rsquo; followed by an integer specifies a
"parameter" of the fault message.  The combination &lsquo;<samp><span class="samp">%.</span></samp>&rsquo; means that the
parameter is the name of a mode or operator.  If "indirect" values are
being used for the bold alphabet, the fault procedure will need to
convert letters in the following identifier.

   <p>The purpose of the message parameter is to allow translation of error
messages into languages other than English without modifying the text
of the compiler.  Except for the removal of &lsquo;<samp><span class="samp">%</span></samp>&rsquo;, it should not be
altered for any other reason.

<h3 class="section"><a name="TOC14"></a>4.6 Output Of Stream Language</h3>

<p>Output of stream language from the compiler is effected by its
repeated calls of the pass 1 shell procedure <code>output</code>,
<pre class="example">     PROC output = (OUTPUT imperative, INT stream) VOID:
     BEGIN
       The procedure encodes the information in the imperative
       and outputs it on the specified stream
     END
</pre>
   <p>The job of this procedure is to output the imperative in whatever form
is most suitable for input to the translator in pass 2.  As this will
depend strongly on the design of the particular translator, the task
of designing the output procedure is best undertaken by the translator
writer himself.

   <p>The mode <code>OUTPUT</code> is a union whose constituent modes represent different
types of imperative, and the first task of the output procedure is to
decompose the union.  The type of the imperative and the data held
within it must now be encoded by the procedure as an implementation-
dependent representation of stream language.  The present document
cannot make any assumptions about such encoding, and will therefore
describe stream language in Algol 68 terms, starting from the mode
<code>OUTPUT</code>.  But it is essential to realise that the output procedure
gives the implementor complete control over the format and content of
the information which is actually output from pass 1.  Some portion
of the data provided is superfluous, being present in the <code>OUTPUT</code>
imperative only for the compiler's own convenience, and this can be
omitted from the stream language representation altogether.  Other
information is `gratuitous', either because it is not strictly
necessary or because it is duplicated.  However, much of this
gratuitous information is likely to be useful to the translator, and
the output procedure should select what is needed in any particular
implementation.

<h2 class="chapter"><a name="TOC15"></a>5 Stream Language In Outline</h2>

<p>An Algol 68 program is concerned with objects and operations on
objects to produce new objects.  For the purpose of code generation, a
translator must construct suitable representations of these objects. 
Such a representation will be termed a "translator value", or simply a
value.  It will normally include the location and size of the item in
the running machine.  In the case of an array or vector - whose total
size is unknown &mdash; a translator value can only describe explicitly the
part which has a fixed size, ie the descriptor or "static part". 
However, translator values do form a sufficient basis for generating
code to handle all objects, whether static or dynamic.

<h3 class="section"><a name="TOC16"></a>5.1 The Imperatives</h3>

<p>Each imperative in stream language belongs to a constituent mode of
the compiler's <code>OUTPUT</code> mode, which is a union.  At the first level of
decomposition, these constituents are
     <dl>
<dt><code>XEDIT</code><dd>used for stream control

     <br><dt><code>XDEC</code><dd>a declaration, which provides data for a new translator value and gives it a declaration number

     <br><dt><code>XROUTINE</code><dd>initiates the declaration of a routine text and gives it a declaration number in a different series

     <br><dt><code>XLOAD</code><dd>requires the translator to construct a new value, or take a given
declared value, and stack it as a reverse Polish operand

     <br><dt><code>XCHARS</code><dd>in conjunction with <code>XLOAD</code>, provides a quotation from the source-text for denotations

     <br><dt><code>XOPER</code><dd>specifies an operation to be performed on the reverse Polish stack

     <br><dt><code>XWARN</code><dd>supplements <code>XOPER</code> by providing advance warning of certain dyadic operations

     <br><dt><code>XPRAG</code><dd>copies the start of source-text pragmats

     <br><dt><code>XCHARPOS</code><dd>indicates character positions in the source-text

     <br><dt><code>XCONTROL</code><dd>indicates the structure of the Algol 68 program

     <br><dt><code>REF VECTOR [] MDE</code><dd>a vector of the modes required for the program

     <br><dt><code>XSIZES</code><dd>giving advance notice of sizes of vectors needed by the translator, such as the above vector of modes

     <br><dt><code>XMODINFO etc</code><dd>concerning modules - see section 3 of Part C. 
</dl>

   <p>We now present the above in more detail.

<h4 class="subsection"><a name="TOC17"></a>5.1.1 <code>XEDIT</code></h4>

<p>The input section of the translator must read in the parallel streams
of imperatives as encoded by the pass 1 output procedure, taking
imperatives variously from one stream and another to form a single
unbranching sequence.  The process of stream collation is performed by
the translator in response to imperatives of mode <code>XEDIT</code>, which it will
encounter on every stream.  An <code>XEDIT</code> is a <code>STRUCT(BOOL up)</code> which tells
the translator to switch to an adjacent stream, one up or one down
from that currently being read, according as <code>up</code> is <code>TRUE</code> or <code>FALSE</code>. 
Reading starts on stream 0 (which contains module information only),
and the next streams down are 1, 2 etc.  After switching to a new
stream, reading always continues from the place where that stream was
last left (or from its beginning if not yet read at all) until an
<code>XEDIT</code> is met.  Throughout the remainder of the present account, this
collation will be assumed to have been done.

<h4 class="subsection"><a name="TOC18"></a>5.1.2 <code>REF VECTOR [] MDE</code></h4>

<p>A vector of modes is passed to the translator in a preliminary
<code>REF VECTOR [] MDE</code> imperative, enabling the translator to represent
any mode as an integer index.

<h4 class="subsection"><a name="TOC19"></a>5.1.3 <code>XDEC</code></h4>

<p>An imperative of mode <code>XDEC</code> is a stream language declaration which
requires the translator to construct a new value, and be able to refer
to it by means of a declaration number supplied in the <code>XDEC</code>.  The mode
<code>XDEC</code> is itself a union of <code>XIDDEC</code> and <code>XLABDEC</code>.  When the source-text
declares an identifier, the stream language will generally produce an
<code>XIDDEC</code> containing its source mode and a declaration number <code>decno</code>. 
(The exception is the Algol 68 routine text declaration, which is
handled separately &mdash; see <code>XROUTINE</code>.)  At the beginning of a serial
clause in which a label setting occurs, the stream language will
produce an <code>XLABDEC</code> which provides the label with a <code>labno</code> (in a
series distinct from the <code>decno</code> series).

<h4 class="subsection"><a name="TOC20"></a>5.1.4 <code>XROUTINE</code></h4>

<p>Every routine text in the source, whether or not it is part of an
Algol 68 declaration, is given an <code>rdenno</code> by an <code>XROUTINE</code> imperative,
which represents the start of the routine.  For certain purposes the
compiler invents its own routines; these synthetic routines are also
declared and numbered in the <code>rdenno</code> series.

<h4 class="subsection"><a name="TOC21"></a>5.1.5 <code>XSIZES</code></h4>

<p>Declaration numbers enable the translator to keep declared values in
vectors for future use.  Numbers in the <code>decno</code> series are issued and
re-issued by the compiler in a stack-like fashion which corresponds to
the nesting of source-text ranges - so a given <code>decno</code> may correspond to
different identifiers in different non-overlapping ranges.  This does
not, however, apply to <code>labno</code>s or <code>rdenno</code>s.  The required vector sizes
in the translator are given in an initial <code>XSIZES</code> imperative of the
form
<pre class="example">     STRUCT (INT norden, nomodes, nolabs, nodecnos,
                     nomodules, nolibinds )
</pre>
   <p>The fields give the vector sizes for <code>rdenno</code>s, <code>VECTOR [] MDE</code>, <code>labno</code>s,
<code>decno</code>s and two vectors concerned with modules (see Part C).

<h4 class="subsection"><a name="TOC22"></a>5.1.6 <code>XLOAD</code></h4>

<p>Stream language differs from Algol 68 in that it breaks down all of
the source text into operations which are judged to be primitive for
the production of code.  It adopts the principle that all of the
operands necessary for any operation must be present on a stack before
the operation can be carried out; the operation is thought of as
replacing its operand(s) by a single result which is kept as an
operand for some future operation.  The imperative which produces a
new operand on the stack in <code>XLOAD</code>.  Any value which has been declared
in an <code>XDEC</code> or <code>XROUTINE</code> can be the object of an <code>XLOAD</code> imperative.  So
also can values corresponding to source-text denotations (see <code>XCHARS</code>),
generators, and the results of alien or code insertions.

<h4 class="subsection"><a name="TOC23"></a>5.1.7 <code>XCHARS</code></h4>

<p>Imperatives of mode <code>XCHARS</code> always amplify an <code>XLOAD</code> for a source-text
string or format denotation, or alien or code insertion.  The <code>XCHARS</code>
imperatives provide quotations from the source-text.

<h4 class="subsection"><a name="TOC24"></a>5.1.8 <code>XOPER</code></h4>

<p>The actual operations which can be carried out on loaded values are
described by imperatives of mode <code>XOPER</code>, which are ultimately defined
by the object code they must produce.  They fall into the following
categories

     <dl>
<dt>monadic and dyadic operators<dd>From the Algol 68 standard prelude.

     <br><dt>coercions and similar operations<dd>Stream language specifies these explicitly wherever they are required.

     <br><dt>field selection and array indexing<dd>For example, given the operands
<code>a</code>, <code>i</code> and <code>j</code>, one operation produces a value for
<code>a[i, j]</code>.

     <br><dt>procedure calls<dd>Which produce, for example, a value for the result
of <code>f(x, y)</code> from the operands <code>f</code>, <code>x</code> and <code>y</code>.  This is not a primitive
operation, as it needs one <code>XOPER</code> to set up the actual parameters and
another to do the procedure call.

     <br><dt>assignment<dd>The primitive stream language operation assigns an object
of known size, or a vector or one-dimensional array of such objects. 
More complicated assignments are reduced to this primitive level by
the compiler.  An Algol 68 assignment to a flex variable is broken
down into two separate stream language operations.  One finds new
space for the elements, copies them into it and makes up the
descriptor.  The other assigns the descriptor to the flex variable.

     <br><dt>space finding<dd>An <code>XOPER</code> generates space for elements of vectors or
arrays whenever required as a result of a source-text declaration or
or generator, or an assignment to a flex variable.  "Static" space is
found in various ways.  The static space required for a named object
is found by means of its <code>XIDDEC</code>.  Unnamed objects, ie generated
objects, obviously cannot be dealt with in this way.  If they are of
fixed size, the space is found by an <code>XLOAD</code> which puts the reference
on the reverse Polish stack.  Otherwise, the fixed part of the total
space requirement is found by an <code>XOPER</code>.  This particular <code>XOPER</code>
is only used when some part of the static space is needed for
descriptors.

     <br><dt>straightening<dd>Two operators provide coercion of a row, vector, struct, i-struct or
union to a "straight" &mdash; a language extension described in Appendix
4.  A third operation provides indexing of the straight to pick out
one member. 
</dl>

<h4 class="subsection"><a name="TOC25"></a>5.1.9 <code>XWARN</code></h4>

<p>For the convenience of certain translator designs, the <code>XWARN</code>
imperative defines certain dyadic operations after the loading of
the first operand.  This is additional to the <code>XOPER</code> which occurs in
the normal reverse Polish position.

<h4 class="subsection"><a name="TOC26"></a>5.1.10 <code>XPRAG</code></h4>

<p>The compiler normally passes the first line of a source-text pragmat
to stream language.

<h4 class="subsection"><a name="TOC27"></a>5.1.11 <code>XCHARPOS</code></h4>

<p>The character positions of significant symbols in the source-text (eg
controls) is output so that the translator will read the imperative at
the appropriate time.

<h4 class="subsection"><a name="TOC28"></a>5.1.12 <code>XCONTROL</code></h4>

<p>Overall structure of Algol 68 source-text is mirrored in stream
language down to the phrase level.  The source text symbols which
delimit phrases appear in stream language as imperatives of mode
<code>XCONTROL</code>, which is a structure with a <code>fn</code> field for the particular
delimiter (<code>xif</code>, <code>xsemi</code>, etc).  The opening round bracket for an
ordinary closed clause and that for a collateral are distinguished by
the compiler and given different <code>fn</code> fields.  This is a typical
example of advance information from the compiler.  Every <code>XCONTROL</code> at
the start of a serial clause gives advance information about the
properties of that clause, such as the presence of declarations and
the mode of the result delivered.

<h3 class="section"><a name="TOC29"></a>5.2 Syntax Analysis Of Stream Language</h3>

<p>An abridged syntax of stream language is shown below.  In this syntax,
the imperatives <code>XLOAD</code>, <code>XOPER</code>, <code>XIDDEC</code> And <code>XLABDEC</code> are all grouped
together, as they do not contribute to syntactic structure in any
significant way.  Structure is imposed on stream language by the
<code>XCONTROL</code> imperatives, whose <code>fn</code> fields enable the various different
types of closed clause to be recognised and their component clauses to
be picked out.

   <p>The task of a translator is to read and act on stream language, and
it can use procedures which mirror the syntax.  To read in a closed
clause, it can use a procedure cclause which calls another procedure,
sc, to read the component serial clauses, as shown in the lower half
of the skeleton translator.  The variable <code>currentxc</code> holds the latest
<code>XCONTROL</code> Imperative.  Similarly, the <code>sc</code> and <code>cclause</code> procedures can
call on a phrase procedure to read the constituent phrases.  After a
call of phrase, the current <code>XCONTROL</code> will obviously be one which
terminated a phrase, and all but two of these also terminate a serial
clause.  These two are <code>xsemi</code> and <code>xexit</code>, which correspond to &lsquo;<samp><span class="samp">;</span></samp>&rsquo; and
<code>EXIT</code> between phrases in the Algol 68 source-text.

   <p>The phrase procedure does the actual reading of the imperatives,
calling <code>cclause</code> when it reads an <code>XCONTROL</code> which is a `cclause
starter', ie one of
<code>
xbegin, xif, xcase, xcaseu, xcoll, xdo (when not preceded by xwhile), xwhile
</code>
in the abridged grammar we are using.  Exit from the phrase procedure
occurs when an <code>XCONTROL</code> which is a `phrase terminator' is read, ie one
of the following:
<pre class="example">           xend        xcollcomma
           xthen       xendcoll
           xelse       xroutinend
           xfi         xinu
           xod         xdo (when preceded by xwhile)
           xin         xcommau
           xcomma      xoutu
           xout
           xesac       xsemi ) these phrase terminators do
           xesacu      xexit ) not terminate serial clauses
</pre>
   <h4 class="subsection"><a name="TOC30"></a>5.2.1 Abridged Syntax Of Stream Language</h4>

<h5 class="subsubsection"><a name="TOC31"></a>5.2.1.1 Notation</h5>

<p>Class names are placed on the left, with their alternative expansions
on separate lines on the right.

   <p>Square brackets enclose an optional item, which, if starred, can be
repeated any number of times.

   <p><code>cclause</code> stands for closed clause, <code>sc</code> for serial clause, <code>enq</code> for
enquiry clause.  A stream language primary is not to be confused with
a primary in Algol 68.

   <p><code>xbegin</code>, <code>xend</code> etc are imperatives of mode <code>XCONTROL</code>, whose
<code>fn</code> fields
are the integers <code>xbegin</code>, <code>xend</code> etc.

<h5 class="subsubsection"><a name="TOC32"></a>5.2.1.2 Syntax rules</h5>

<pre class="example">     cclause = xbegin  sc  xend
               xif  enq  xthen  sc  [xelse  sc]  xfi
               xcase  enq  xin  phrase  [xcomma  phrase]*  [xout sc]  xesac
               xcoll  phrase  [xcollcomma  phrase]*  xendcoll
               xcaseu  enq  xinu phrase [xcommau phrase]* [xoutu sc] xesacu
               [phrase]  [phrase]  [phrase]  xfor  [xiddec]  loop
               [phrase]*  xforall  [xiddec]*  loop
     
     loop    = [xwhile  sc]  xdo  sc  xod
     
     sc      = phrase  [separator  phrase]*
     
     enq     = phrase  [xsemi  phrase]*
     
     phrase  = primary  [primary]*
     
     primary = XLOAD
               XOPER
               XIDDEC
               XLABDEC
               XROUTINE  phrase  xroutinend
               cclause
     
     separator = xsemi
                 xexit
</pre>
<h5 class="subsubsection"><a name="TOC33"></a>5.2.1.3 Skeleton translator &mdash; stage 1</h5>

<pre class="example">     XCONTROL currentxc;
     
     PROC read = OUTPUT:  "deliver next imperative";
     
     
     PROC phrase = VOID:
     BEGIN
            DO  CASE read
                IN  (XLOAD):
                        ----,
                    (XOPER):
                        ----,
                    (XIDDEC):
                        ----,
                    (XLABDEC):
                        -----,
                    (XROUTINE):
                        phrase,
                    (XCONTROL xc):
                        (currentxc := xc;
                         IF  fn OF xc = "cclause starter"
                         THEN  cclause
                         ELIF  fn OF xc = "phrase terminator"
                         THEN  GOTO out
                         FI
                        )
                ESAC
            OD;
     out:   SKIP
     END;
     
     
     PROC sc = VOID:
     WHILE  phrase;
            fn OF currentxc = xsemi  OREL  fn OF currentxc = xexit
     DO  SKIP  OD;
     
     
     PROC cclause = VOID:
     IF  fn OF currentxc = xbegin
     THEN  sc
     ELIF  fn OF currentxc = xif
     THEN  sc;
           sc;
           IF  fn OF currentxc = xelse  THEN  sc  FI
     ELIF  fn OF currentxc = xcase
     THEN  sc;
           phrase
           WHILE  fn OF currentxc = xcomma  DO  phrase  OD;
           IF  fn OF currentxc = xout  THEN  phrase  FI
     ELIF  fn OF currentxc = xcoll
     THEN  phrase;
           WHILE  fn OF currentxc = xcollcomma  DO  phrase  OD
     ELSE  "see stage 2 for other controls"
     FI;
</pre>
<h3 class="section"><a name="TOC34"></a>5.3 The Reverse Polish Stack</h3>

<p>In a reverse Polish language, operands "lie dormant" until an
operation on them is specified, but it does not necessarily follow
that the translator must maintain a reverse Polish stack.  For certain
types of machine it would be feasible to generate object code from
each <code>XLOAD</code> immediately it appeared, and keep no record in the
translator.  For most types of machine, however, it will be desirable
to be able to delay the production of code for operand settings at
least until all the operands are present and an actual operation has
been specified.  This delay is a simple technique for optimisation;
decisions about the best form of code cannot always be made when a
value is first placed on the reverse Polish stack.  Even after an
<code>XOPER</code> has appeared, it may be desirable to hold up the production of
code.  For example, when translating for a single address machine, it
has been found best to delay the operations of dereferencing, field
selection and array indexing.  When this is done, the resulting value
on the reverse Polish stack has to embody enough information to enable
the required address calculations and code production to be carried
out later.

   <p>In Algol 68, a reverse Polish stack can be implemented very simply. 
Stage 2 of the skeleton translator given below includes the
declaration of a stack reference variable <code>vss</code> local to the phrase
procedure.  More will be said about this localisation at a later
stage, but as the translator is highly recursive, it implies that
local sections of the overall reverse Polish stack are distributed
in the procedural stack of the translator.  A new value must be
constructed and put on the local stack at each <code>XLOAD</code> imperative and
for the result of each closed clause.  In Algol 68, a closed clause
always delivers its result to the phrase which contains it, and the
translator's value for this result must therefore be loaded on the
stack local to the phrase.  In fact, the value is constructed (at
least in part) as soon as the <code>XCONTROL</code> announces the start of a
closed clause.  Part of the value will be the mode of the result of
the closed clause, which is given in the <code>XCONTROL</code> imperative. 
Another part will be the location used for the result in the object
machine.  This may or may not be allocated immediately, but in any
case the procedure <code>cclause</code> will require access to is for code
generation purposes.  The value is therefore passed from phrase to
<code>cclause</code> as a parameter, and we have made it a <code>REF VALUE</code> parameter
to permit communication in either direction.  In the skeleton, this
happens after the condition <code>m OF xc &gt; 0</code>, which should be assumed
for the time being to be <code>TRUE</code>.  The <code>REF VALUE</code> is passed from <code>cclause</code>
to every subservient procedure, including recursive calls of <code>phrase</code>.

   <p>A phrase delivers a result, possibly void, but always leaving a single
value on its reverse Polish stack.  If ths phrase is terminated by a
semicolon, the result is written off (by the rules of Algol 68) and
this is mirrored in the translator by the disappearance of the stack
on exit from the procedure.  However, if the phrase is the last in a
serial clause - or is terminated by an <code>EXIT</code> in the source text &mdash; the
result must be preserved by the object code for future use.  A value
already exists for it on the stack in an outer phrase and is
accessible as the <code>answer</code> parameter of the inner phrase under
discussion.  The last act before exit from <code>phrase</code> is therefore to
generate code, as necessary, to ensure that the location of the result
agrees with that in <code>answer</code>.  The local stack then serves no further
purpose and can safely be allowed to pass out of scope.

   <p>The test <code>m OF xc &gt; 0</code> is an optimising device to deal with a closed
clause whose result is known (by the compiler) to be the result also
of an outer serial clause &mdash; described in the <code>answer</code> parameter of
the current phrase.  Thus at the arrow in
<pre class="example">                 (a;  (b;  c))
                      ^
</pre>
   <p>a value for the result of <code>(b; c)</code> has already been constructed at the
beginning of the outer serial clause, and can simply be passed on.  To
indicate this optimisation, which also has implications for code
generation, the compiler sets the <code>m</code> field of the opening <code>XCONTROL</code> at
the arrow negative.  When this is detected in the translator, it calls
<code>cclause(answer)</code> instead of <code>cclause("newly constructed value")</code>.  After
the first closing bracket in the above example, the stack local to the
phrase <code>(b; c)</code> will be <code>NIL</code>, because nothing will have been loaded.  No
action must then be taken at the point in the skeleton labelled
<code>result</code>, for it will already have been taken on exit from the phrase
<code>c</code>.

   <p>In expanding stage 1 of the skeleton to make stage 2, we have
expressed the action for an <code>XROUTINE</code> as a call of the procedure
<code>routine</code>.  Although the body of this procedure is trivial in the
skeleton, it will of course be much larger in an actual translator. 
The call of <code>routine</code> in the translator corresponds to a routine-text
in the program, not a routine call.  The body of the routine-text is
not being obeyed, and the answer parameter for its phrase is therefore
<code>NIL</code>.  Inside That phrase, the <code>NIL</code> should be detected at the label
<code>result</code>.

<h5 class="subsubsection"><a name="TOC35"></a>5.3.0.1 Skeleton translator &mdash; stage 2</h5>

<pre class="example">     XCONTROL currentxc;
     
     PROC read = OUTPUT:  "deliver next imperative";
     
     MODE VALUELIST = STRUCT (VALUE v, REF VALUELIST rest);
     
     
     PROC phrase = (REF VALUE answer) VOID:
     BEGIN
            REF VALUELIST vss := NIL;
            DO  CASE  read
                IN  (XLOAD):
                        vss := LOC VALUELIST := ("given value", vss),
                    (XOPER):
                        ----,
                    (XIDDEC):
                        ----,
                    (XLABDEC):
                        ----,
                    (XROUTINE):
                        routine,
                    (XCONTROL xc):
                        (currentxc := xc;
                         IF  fn OF xc = xwhile
                                 OREL  fn OF xc = xdo ANDTH "no xwhile"
                         THEN  vss := LOC VALUELIST
                                   := ("value for void result", vss);
                               cclause(v OF vss)
                         ELIF  fn OF xc = "cclause starter"
                         THEN  IF  m OF xc &gt; 0
                               THEN  vss := LOC VALUELIST
                                         := ("value for result", vss);
                                     cclause(v OF vss)
                               ELSE  cclause(answer)
                               FI
                         ELIF  fn OF xc = xsemi
                         THEN  GOTO out
                         ELIF  fn OF xc = xfor  OREL  fn OF xc = xforall
                         THEN  "read and unstack information as far
                                as xwhile or xdo"
                         ELIF  fn OF xc = "any other phrase terminator"
                         THEN  GOTO result
                         FI
                        )
                ESAC
            OD;
     
     result:  "ensure that, if vss isn't NIL, the object described by
               v OF vss is properly described by answer";
     out:   SKIP
     END;
     
     PROC routine = VOID:  phrase(NIL);
     
     
     PROC sc = (REF VALUE answer) VOID:
     WHILE  phrase(answer);
            fn OF currentxc = xsemi  OREL  fn OF currentxc = xexit
     DO  SKIP  OD;
     
     
     PROC cclause = (REF VALUE answer) VOID:
     IF  fn OF currentxc = xbegin
     THEN  sc(answer)
     ELIF  fn OF currentxc = xif
     THEN  sc("value for boolean");
           sc(answer);
           IF  fn OF currentxc = xelse THEN sc(answer) FI
     ELIF  fn OF currentxc = xcase
     THEN  sc("value for integer");
           phrase(answer);
           WHILE  fn OF currentxc = xcomma
           DO  phrase(answer)  OD;
           IF  fn OF currentxc = xout  THEN  sc(answer)  FI
     ELIF  fn OF currentxc = xcaseu
     THEN  sc("value for union");
           phrase(answer);
           WHILE  fn OF currentxc = xcommau
           DO  phrase(answer)  OD;
           IF  fn OF currentxc = xoutu  THEN  sc(answer)  FI
     ELIF  fn OF currentxc = xcoll
     THEN  phrase("value for first field of answer");
           FOR i  FROM 2
           WHILE  fn OF currentxc = collcomma
           DO  phrase("value for ith field of answer")  OD
     ELSE  CO  xwhile or xdo  CO
           IF  fn OF currentxc = xwhile
           THEN  sc("value for boolean")
           FI;
           sc(answer)
     FI
</pre>
<h2 class="chapter"><a name="TOC36"></a>6 Stream language in detail</h2>

<p>This chapter completes the account of stream language by supplying all
the detailed factual information.  The hierarchy of imperatives is
organised in two ways, partly by the use of unions (as <code>XIDDEC</code>,
<code>XROUTINE</code> and <code>XLABDEC</code> are united under the mode <code>XDEC</code>), and partly by
characteristic integers (as for example the <code>fn</code> field of an <code>XCONTROL</code>
imperative).  In this text, mnemonics are used in place of actual
integer values, which can be discovered from the listing of the RS
compiler.

   <p>The word "mode" frequently occurs as the selector of an integer field
in an imperative.  The integer should always be understood as an index
to the vector of modes given in the <code>REF VECTOR [] MDE</code> imperative.

   <p>Certain fields of the imperative are present for the convenience of
the compiler itself.  Such fields will be enclosed in curly brackets;
their significance for a translator is nil, and they should not
be output by the compiler shell.

   <p>Some features of stream language may vary slightly between different
implementations of the RS compiling system.  See Appendix 5 for the
list of implementation-dependent declarations in the text of the
compiler.

<h3 class="section"><a name="TOC37"></a>6.1 The Vector Of Modes &mdash; <code>REF VECTOR [] MDE modes</code></h3>

<p>Each different mode used in a program is represented in stream
language by a mode number.  This is the sum of an integer, m say,
representing a non-ref mode, and an offset (<code>refmark</code>) for each <code>REF</code>
at its front.  The actual source mode represented by <code>m</code> is held in the
element <code>modes[m]</code> which yields a <code>MDE</code>.  This is a union of constituent
modes representing structures, procedures etc, as given in the table
below.  These constituent modes contain further mode numbers which can
be similarly decomposed until <code>PRIMITIVE</code> constituents are reached.  The
mode number for all the <code>PRIMITIVE</code> modes are given in Appendix 2, and
are fixed for all programs.  Once these mode numbers have been
reached, the mode is completely known.  However, <code>PRIMITIVE</code> (defined to
be <code>INT</code>) gives "type" information on the primitive mode, defined as the
mode number for the primitive mode stripped of any <code>SHORT</code> or <code>LONG</code>
prefixes.

<h4 class="subsection"><a name="TOC38"></a>6.1.1 Constituent Modes Of <code>MDE</code></h4>

<p>The mode <code>MODELIST</code>, defined as
<pre class="example">     MODE  MODELIST  =  STRUCT (INT mode, REF MODELIST rest)
</pre>
   <p>is used in the following table, although it is not itself a
constituent of <code>MDE</code>.

<h4 class="subsection"><a name="TOC39"></a>6.1.2 <code>REF STRCT</code></h4>

<pre class="example">     MODE  STRCT  =  STRUCT (INT {rdenno}, {deflex}, REF SELIST sels),
</pre>
   <p>in which the mode <code>SELIST</code> is defined as
<pre class="example">     MODE  SELIST  =  STRUCT (INT mode, fieldno, ID name, REF SELIST rest ).
</pre>
   <p>This gives the mode and field number, starting with field 1, for each
of the fields of a structure.  The <code>name</code> field gives the field
selector name, truncated or space-filled to <code>maxid</code> characters (see
Appendix 5), internal spaces having been removed.

<h4 class="subsection"><a name="TOC40"></a>6.1.3 <code>REF ISTRUCT</code></h4>

<pre class="example">     MODE  ISTRUCT  =  STRUCT (INT {rdenno}, imode, length, {deflex}).
</pre>
   <p>This describes an indexable structure having <code>length</code> elements of mode
<code>imode</code>.

<h4 class="subsection"><a name="TOC41"></a>6.1.4 <code>REF VCTOR</code></h4>

<pre class="example">     MODE  VCTOR  =  STRUCT (INT {rdenno}, vecmode, deflex)
</pre>
   <p>This mode describes a vector or flex vector with elements of mode
<code>vecmode</code>.  The <code>deflex</code> field is negative for a flex vector and
positive or zero for a non-flex vector.

<h4 class="subsection"><a name="TOC42"></a>6.1.5 <code>REF ARRAY</code></h4>

<pre class="example">     MODE  ARRAY  =  STRUCT (INT {rdenno}, mode, nods, deflex).
</pre>
   <p>This describes an array or flex array of <code>nods</code> dimensions; <code>mode</code> is
the mode of the array with the front row removed (ie the mode of the
elements for a 1-dimensional array).  The <code>deflex</code> field is negative
for a flex array and positive or zero for a non-flex array.

   <p>For example
     <ul>
<li><code>[] REAL</code> is represented in <code>mode</code> field as <code>REAL</code>

     <li><code>[ , ] REAL</code> is represented in <code>mode</code> field as <code>[]REAL</code>

     <li><code>FLEX [ , ] REAL</code> is represented in <code>mode</code> field as
<code>[] REAL</code>
</ul>

<h4 class="subsection"><a name="TOC43"></a>6.1.6 <code>REF UNN</code></h4>

<pre class="example">     MODE  UNN  =  STRUCT (INT {rdenno}, REF MODELIST modelist)
</pre>
   <p>This describes a union mode, where <code>modelist</code> is a list of all the
constituents (any unions within the union having been decomposed).

<h4 class="subsection"><a name="TOC44"></a>6.1.7 <code>REF PROCP</code></h4>

<pre class="example">     MODE  PROCP  =  STRUCT (INT deproc, REF MODELIST pars)
</pre>
   <p>Describes a procedure with parameters; <code>deproc</code> is the mode of the
result and <code>pars</code> gives the modes of the parameters.

<h4 class="subsection"><a name="TOC45"></a>6.1.8 <code>REF PRC</code></h4>

<pre class="example">     MODE  PRC  =  STRUCT (INT deproc)
</pre>
   <p>Describes a procedure with no parameters and result of mode <code>deproc</code>.

<h4 class="subsection"><a name="TOC46"></a>6.1.9 <code>REF STEN</code></h4>

<pre class="example">     MODE  STEN  =  STRUCT (INT mode, REF STENLIST {stenlist})
</pre>
   <p>Describes a straight of objects of mode <code>mode</code>.

<h4 class="subsection"><a name="TOC47"></a>6.1.10 <code>REF AMODE</code></h4>

<p>No reference to this mode will occur in stream language.

<h4 class="subsection"><a name="TOC48"></a>6.1.11 <code>SAMEAS</code></h4>

<p>Except in the table of modes, no reference to this mode will occur in
stream language.

<h4 class="subsection"><a name="TOC49"></a>6.1.12 <code>PRIMITIVE</code></h4>

<pre class="example">     MODE  PRIMITIVE  =  INT;
</pre>
   <p>The <code>MDE</code> vector contains elements for all the primitive modes, which
always occupy fixed places at the bottom of the vector, as given in
Appendix 2.  The index, ie the mode number, therefore determines the
primitive mode uniquely.  When a <code>MDE</code> element decomposes to <code>PRIMITIVE</code>,
the integer value specifies the type of the mode, defined as the
primitive mode with any <code>SHORT</code>s or <code>LONG</code>s removed.  For example, the
<code>MDE</code> element <code>modes[20] (LONG REAL)</code> will decompose to <code>PRIMITIVE</code> and have
value 19 (<code>REAL</code>).

<h3 class="section"><a name="TOC50"></a>6.2 Identifier Declarations (<code>XIDDEC</code> from <code>XDEC</code>)</h3>

<p>These imperatives introduce declaration numbers in the <code>decno</code> series
and also imply storage allocation for the object machine.  The
definition of an identifier in the source text gives rise to an <code>XIDDEC</code>
(except in the case of routine identity declarations covered by
<code>XROUTINE</code> In B3.3).  The mode <code>XIDDEC</code> is given by
<pre class="example">     MODE  XIDDEC  =  STRUCT (INT type, REF IDDEC iddec)
</pre>
   <p>The <code>iddec</code> field refers to information in the following structure
<pre class="example">     MODE  IDDEC  =  STRUCT (ID name, INT decno, {level}, mode,
                             INT {scope}, REF IDDEC {rest} )
</pre>
   <p>The <code>name</code> field gives the source text identifier or operator symbol
(truncated or space-filled to <code>maxid</code> characters, internal spaces
having been removed), and <code>mode</code> gives its mode.  The declaration
number <code>decno</code> is used to index a vector in which the translator can
keep a record of values constructed in response to the <code>XIDDEC</code>.  The
<code>decno</code>s start at 4.

   <p>The <code>type</code> field of an <code>XIDDEC</code> is one of the following

     <dl>
<dt><code>xiddec</code><dd>Identity declaration.  When this imperative occurs, the
            top item on the reverse Polish stack (which must be
            removed) will be the value for a static object or the
            static part of a dynamic object.  Code must be generated,
            if necessary, to preserve this object, and a value
            constructed to describe it.

     <br><dt><code>xvardec</code><dd>Reference declaration for a static object.  Space must be
            found for the object and a value constructed to describe
            the reference to it.

     <br><dt><code>xivardec</code><dd>Initialised reference declaration.  The top item on the
            reverse Polish stack (which must be removed) will be the
            initial value for a static object or the static part of a
            dynamic object.  Space must be found for this, and a value
            constructed to describe the reference.

     <br><dt><code>xfdec</code><dd>Specifies a formal parameter of a procedure.

     <br><dt><code>xccdec</code><dd>Introduces the formal identifier in a conformity.

     <br><dt><code>xfordec</code><dd>Introduces the identifier after FOR in a loop clause.

     <br><dt><code>xforalldec</code><dd>Introduces an identifier defined in a FORALL statement.

     <br><dt><code>xdummydec</code><dd>A pseudo declaration introduced by the compiler in order
            to indicate the scopes of some routines. 
</dl>

<h3 class="section"><a name="TOC51"></a>6.3 Routine Text Declarations, <code>XROUTINE</code></h3>

<p>Every occurrence of a routine text (which may appear at any point in
stream language) gives rise to an opening <code>XROUTINE</code> imperative, as also
do routines invented by the compiler for certain tasks.  A routine
text is terminated by the <code>XCONTROL</code> with function <code>xroutinend</code>.  The
mode <code>XROUTINE</code> is given by
<pre class="example">     MODE  XROUTINE  =  REF RDEN,
</pre>
   <p>where
<pre class="example">     MODE  RDEN  =  STRUCT (ID name, BITS props, INT mode, rdenno,
                            INT maxname, {level}, REF RDEN {rest} )
</pre>
   <p>The <code>name</code> field contains one of the following

     <dl>
<dt><em>the identifier</em><dd>from a brief declaration of a procedure or operator, as shown below
     <pre class="example">          PROC  p  =  routine text
          OP  P  =  routine text
</pre>
     <p>Such declarations do not give rise to <code>XIDDEC</code> imperatives. 
The identifier is truncated or space-filled to <code>maxid</code> characters, internal
spaces having been removed.

     <br><dt><code>" anonymous  "</code><dd>when the Algol 68 routine text was not the subject of a brief
declaration. 
The routine may have been declared fully, as in
     <pre class="example">          PROC (INT) INT p  =  (INT n) INT: ... ,
</pre>
     <p>in which case an <code>XIDDEC</code> imperative is produced for <code>p</code>.

     <br><dt><code>" generator  "</code><dd>for a synthetic space generation routine (ie invented by the compiler).

     <br><dt><code>" assignment "</code><dd>for a synthetic assignment routine.

     <br><dt><code>" straight   "</code><dd>for a synthetic routine for indexing a straight.

     <br><dt><code>" format     "</code><dd>for a synthetic routine containing the bodies of <code>n</code>, <code>f</code> and <code>g</code> patterns from a format. 
</dl>

   <p>The <code>props</code> field is made up as a conjunction of bits values of the
form <em>2**n</em>.  These are denoted mnemonically (eg <code>ccbit</code>) and represent
attributes of a particular routine-text.

   <p>The bits values are
     <dl>
<dt><code>ccbit</code><dd>routine has a body consisting of a closed clause

     <br><dt><code>operatorbit</code><dd>routine is part of a brief operator declaration

     <br><dt><code>valbit</code><dd>routine is to be loaded onto the translator stack, despite the absence
of an <code>XLOAD</code> imperative

     <br><dt><code>holebit</code><dd>routine contains a <code>HERE</code> clause (see Part C)

     <br><dt><code>globscopebit</code><dd>routine is a straightening or assignment procedure with no non-locals

     <br><dt><code>genprocbit</code><dd>routine is a synthetic generation routine
</dl>

   <p>The <code>mode</code> field is the mode of the routine and its declaration number
is <code>rdenno</code>.  Declaration numbers for routines are in a separate
series which starts at <code>startrd + 1</code> (see Appendix 5).

   <p>The field <code>maxname</code> is less than 3 for a routine text of unlimited
lifetime and 3 if its only external identifiers are declared in
modules compiled at <code>CONTEXT VOID</code> (See C2.10).  Otherwise, <code>maxname</code> is
the <code>decno</code> of an identifier of smallest lifetime used within the
routine but not declared in it.  This, in combination with
information given in any <code>XLABDEC</code>s at the beginning of the routine,
can be used to determine the lifetime of the routine.  However,
<code>XLABDEC</code> imperatives are not given at the start of synthetic routines.

<h3 class="section"><a name="TOC52"></a>6.4 Label Declarations (<code>XLABDEC</code> from <code>XDEC</code>)</h3>

<p>In Algol 68, label identifiers can be re-used for different label
settings, but in stream language each different label setting has a
different label number (<code>Labno</code>).  <code>XLABDEC</code> imperatives occur at
positions where labels must be set and also at the beginnings of
serial clauses and routines.

   <p>The mode <code>XLABDEC</code> is given by
<pre class="example">     MODE  XLABDEC  =  STRUCT (REF LABEL lab, BOOL notsetting),
</pre>
   <p>where
<pre class="example">     MODE  LABEL  =  STRUCT (ID name, INT labno, status, REF LABEL {rest} )
</pre>
   <p>At an actual label setting, <code>notsetting</code> is <code>FALSE</code> and <code>status</code> is
undefined.  All other occurrences of an <code>XLABDEC</code> are at the beginnings
of serial clauses or routines, and <code>notsetting</code> is <code>TRUE</code>.  The purpose
of the imperative then depends on the value of <code>Status</code>.  If <code>status</code>
is 0, the <code>XLABDEC</code> is at the start of a serial clause and gives the
<code>labno</code> of a label which will be set in it.  If <code>status</code> is <code>s</code>, where
<code>s &gt; 1</code>, the <code>labno</code> is to be taken as a new label number for the label
previously numbered <code>s</code>.  If <code>status</code> is 1, the <code>XLABDEC</code> is at the start
of a user-written routine, and gives the <code>labno</code> of an external label
in a <code>GOTO label</code> occurring in the body of the routine.  This
information is required for defining the scope of the routine.

   <p>The field <code>name</code> is the source-text identifier, truncated or
space-filled to <code>maxid</code> characters, internal spaces having been
removed.

<h3 class="section"><a name="TOC53"></a>6.5 The Loading Imperative, <code>XLOAD</code>, And <code>XCHARS</code></h3>

<p>An <code>XLOAD</code> imperative requires a value to be loaded on the reverse
Polish stack.  The mode XLOAD is a union of the following modes.

<h4 class="subsection"><a name="TOC54"></a>6.5.1 <code>BOOL</code></h4>

<p>This derives from a boolean denotation in the source-text, and the
value will be <code>TRUE</code> for <code>TRUE</code> and <code>FALSE</code> for <code>FALSE</code>.

<h4 class="subsection"><a name="TOC55"></a>6.5.2 <code>INT</code></h4>

<p>The integer is the <code>decno</code> or <code>rdenno</code> of a previously declared value to
be loaded.

<h4 class="subsection"><a name="TOC56"></a>6.5.3 <code>REF LABEL</code></h4>

<p>This is the <code>lab</code> field of an <code>XLABDEC</code> imperative.  The value
corresponding to the <code>labno</code> must be loaded.

<h4 class="subsection"><a name="TOC57"></a>6.5.4 <code>STRUCT (INT Nse)</code></h4>

<p>A value for <code>NIL</code>, <code>SKIP</code> or <code>EMPTY</code>, according as <code>Nse</code> is
<code>nilmode</code>,
<code>skipmode</code> or <code>voidmode</code>.

<h4 class="subsection"><a name="TOC58"></a>6.5.5 <code>XGEN  =  STRUCT (INT mode, BOOL loc)</code></h4>

<p>The <code>mode</code> field will be a ref to the mode of a static object.  Space
must be dynamically generated for the object, locally or on the heap
according as <code>loc</code> is <code>TRUE</code> or <code>FALSE</code>.  A value must be loaded to
describe the reference.

<h4 class="subsection"><a name="TOC59"></a>6.5.6 <code>XNUMBER =  STRUCT (INT mode, REF VECTOR [] CHAR nu)</code></h4>

<p>This imperative represents a number denotation in the source-text. 
The <code>mode</code> field will be <code>bits</code>, <code>int</code> or <code>real</code>
(possibly with <code>LONG</code> or <code>SHORT</code> prefixes) and the
<code>nu</code> field refers to the actual denotation in a standard format
as follows.

   <p>For a value of mode <code>BITS</code>, the format is:

<pre class="example">     radix digits
</pre>
   <p>where <code>radix</code> is the character &lsquo;<samp><span class="samp">2</span></samp>&rsquo;, &lsquo;<samp><span class="samp">4</span></samp>&rsquo;, &lsquo;<samp><span class="samp">8</span></samp>&rsquo; or
&lsquo;<samp><span class="samp">g</span></samp>&rsquo; (for sixteen) and digits is a digit sequence using
the letters &lsquo;<samp><span class="samp">a</span></samp>&rsquo; to &lsquo;<samp><span class="samp">f</span></samp>&rsquo; for the digits ten to fifteen as
required in hexadecimal numbers.

   <p>For an integer, the format is:
<pre class="example">     a  digits     (where the character "a" means radix 10)*
</pre>
   <p>For a real, the format is:
<pre class="example">     r  [digits]  [dchar digits]  [signletter digits]
</pre>
   <p>The square brackets (not part of the denotation) indicate parts which
may be absent, though at least one will be present.  The character <code>r</code>
indicates "real", <code>dchar</code> denotes decimal point, and <code>signletter</code> is
the character <code>pchar</code> for plus or <code>nchar</code> for minus*.  The digits
after this are the exponent.

   <p>There are no space characters in the above number representations.

   <p>The following imperatives are each followed by one or more
<code>OUTPUT(XCHARS)</code> imperatives giving the relevant source-text quotations
(see <code>XCHARS</code>).

<h4 class="subsection"><a name="TOC60"></a>6.5.7 <code>XSTRING  =  STRUCT (INT strmode)</code></h4>

<p>For a string denotation containing one character only, <code>strmode</code> is
<code>char</code>.  For a denotation containing <code>n</code> characters (<code>n /= 1</code>),
<code>strmode</code> is
<code>STRUCT n CHAR</code> (including when <code>n</code> is zero).

<h4 class="subsection"><a name="TOC61"></a>6.5.8 <code>XFORMAT  =  STRUCT (INT nochars, nocases, w)</code></h4>

<p>The text of a format denotation is introduced by an <code>XLOAD(XFORMAT)</code>
imperative, after which there are one or mode <code>XCHARS</code> imperatives, each
corresponding to a line of the source-text.  If there are any <code>n</code>, <code>f</code> or
<code>g(uc)</code> patterns in the format, The <code>XFORMAT</code> is preceded by the loading
of a routine text, whose body consists of a case-clause.  The cases
are the enclosed clauses from the <code>n</code> and <code>f</code> patterns, together with any
unitary clauses used in <code>g</code> patterns.  The order is identical to that
of the source-text.

   <p><code>nochars</code> is the number of chars in the succeeding <code>XCHARS</code> imperatives. 
<code>nocases</code> is the number of <code>n</code>, <code>f</code> or <code>g(uc)</code> patterns in the
format. 
<code>w</code> is the maximum nesting depth of collection lists in formats.

   <p>For example,
<code>w = 2</code>  for  <code>$ 2 (G, 3 ("LINE" A L)) $</code>,
<code>w = 0</code>  for  <code>$ d $</code>

<h4 class="subsection"><a name="TOC62"></a>6.5.9 <code>XALIEN  =  STRUCT (INT almode)</code></h4>

<p>Describes the source-text construction
<pre class="example">     ALIEN "insertion"
</pre>
   <p>which occurs on the right of an identity declaration.  The field
<code>almode</code> gives the mode, and succeeding <code>XCHARS</code> imperatives contain
the insertion.

<h4 class="subsection"><a name="TOC63"></a>6.5.10 <code>XCODE  =  STRUCT (INT mode, nopars)</code></h4>

<p>A source-text code insertion has the form
<pre class="example">     mode CODE (unc, unc, ... ) "code"
</pre>
   <p>where mode is optional, absence implying <code>VOID</code>.  Stream language for
the unitary clauses (uncs) comes first, and their results will be on
the stack when the <code>XLOAD(XCODE)</code> imperative is given.  The <code>mode</code> field
gives the mode and <code>nopars</code> the number of uncs.  The succeeding <code>XCHARS</code>
imperatives give the code.

<h4 class="subsection"><a name="TOC64"></a>6.5.11 <code>XCHARS  =  STRUCT (INT nochars, base, REF VECTOR [] CHAR chars)</code></h4>

<p>This imperative is not a constituent of the mode <code>XLOAD</code>, but
is included in this section because it always follows an <code>XLOAD</code> or a
previous <code>XCHARS</code> of which it is a continuation.

   <p>Successive <code>XCHARS</code> imperatives represent the successive instalments of
one source-text string or format denotation, which may have been
broken, for instance by new lines.  In the case of a format, these are
the only source of breaks.  In the case of strings, a new instalment
occurs when, in the source-text, a closing quote character is
followed, after spaces or new lines or a new radix, by an opening
quote character.  However, any instalments containing no characters
are skipped over, unless final.

     <dl>
<dt><code>nochars</code><dd>For the final instalment, this is <code>UPB chars</code> (and may of
           course be 0).  For all preceding instalments, it is
           <code>- UPB chars</code> (/= 0).

     <br><dt><code>base</code><dd>f the <code>chars</code> field contains a "radix string", the <code>base</code>
           field gives the base, which will be 2, 4, 8, 10 or 16. 
           Otherwise, the base is 0.  In particular, it is 0 for a
           format denotation.

     <br><dt><code>chars</code><dd>n string denotations (following <code>XSTRING</code>, <code>XALIEN</code> or <code>XCODE</code>),
           the enclosing quote characters in the source-text are
           excluded.  Any doubled quote within the source-text
           denotation appears as a single quote character in <code>chars</code>. 
           However, these remarks do not apply to string denotations
           inside formats, which are reproduced literally.

     <p>In format denotations, the opening <code>$</code> is replaced by a space
           but the closing <code>$</code> is included.  Otherwise, spaces are
           removed except where meaningful.  Thus if two successive
           string denotations within a format are separated in the
           source-text by one or more spaces, one space is retained. 
           Similarly, if the strings are separated by a new line in
           the source-text, the break will introduce a space as the
           final character in the <code>chars</code> field of the <code>XCHARS</code> which
           finishes at the new line.  The format will then continue
           in a new <code>XCHARS</code>.  Thus, when the format interpreter
           concatenates the "chars" fields of successive <code>XCHARS</code>
           imperatives, quote characters will not be brought into
           contact and be misinterpreted as a quote character within
           a string.

     <p>Comments within formats are also removed.  The body of an <code>n</code>
           or <code>f</code> pattern is replaced by an integer giving its position
           in the format, eg the second pattern would become <code>n(2)</code> or
           <code>f(2)</code>.  This applies to clauses in <code>g</code> patterns, which are also
           replaced by <code>n(x)</code>, where <code>x</code> is an integer giving its position
           in the format.  All three types are numbered from 1 in the
           same series. 
</dl>

<h3 class="section"><a name="TOC65"></a>6.6 Operations, <code>XOPER</code></h3>

<p>The mode <code>XOPER</code> is defined as
<pre class="example">     MODE  XOPER  =  STRUCT (INT fn, m, param)
</pre>
   <p>The <code>fn</code> field specifies an operation for which code must usually be
generated.  The operation applies to one or more objects (operands)
for which translator values will exist on the reverse Polish stack. 
These values must be removed from the stack and replaced by a value
for the result of the operation (except for <code>xparampack</code> which gives
no result).

   <p>The <code>m</code> field gives the mode of the result, unless otherwise stated.

   <p>The <code>param</code> field is used for additional information, but if not
mentioned in the tables below, it can be assumed undefined.

<h4 class="subsection"><a name="TOC66"></a>6.6.1 Standard prelude operators</h4>

     <dl>
<dt><code>xmonop</code><dd>1 operand. <code>param</code> = 16 * opnumber + version number. 
         The operators and corresponding opnumbers are listed in
         Appendix 3 (monadic operators).  A given operator has
         different versions for different modes of operand.

     <br><dt><code>xdyop</code><dd>2 operands. <code>param</code> = 16 * opnumber + version number. 
The opnumbers and version numbers are given in Appendix 3
         (dyadic operators).  The mode given at the head of the table
         applies to one operand and is sufficient to identify what is
         required for a particular version.  Versions for arithmetic
         and relational operators between ints, reals and complexes
         need only deal with operands of like mode, as the compiler
         will supply a widening coercion for one operand where
         necessary. 
</dl>

<h4 class="subsection"><a name="TOC67"></a>6.6.2 Coercions and similar operations</h4>

     <dl>
<dt><code>xderef</code><dd>1 operand, an object to be dereferenced.

     <br><dt><code>xunite</code><dd>1 operand, an object to be united.  The mode of the object
           will not itself be a union; it will be the <code>param</code>th mode
           (starting at 1) of the union <code>m</code>.

     <br><dt><code>xuniteu</code><dd>1 operand, an object having a union mode, to be united in mode <code>m</code>.

     <br><dt><code>xdeunite</code><dd>1 operand, a ref union to become a ref to its current constituent mode, but flexed as given by <code>m</code>.

     <br><dt><code>xwrc*</code><dd>1 operand, a real to be widened to complex.

     <br><dt><code>xwir*</code><dd>1 operand, an int to be widened to real.

     <br><dt><code>xwbvb*</code><dd>1 operand, a bits to be widened to vector of bool.

     <br><dt><code>xarr</code><dd>1 operand, a (ref) M to become a (ref) array of M.

     <br><dt><code>xarrarr</code><dd>1 operand, a (ref) array to become a (ref) array with an extra dimension.

     <br><dt><code>xvecarr</code><dd>1 operand, a (ref) vector to become a one-dimensional (ref) array.

     <br><dt><code>xisarr</code><dd>1 operand, an object of mode
     <pre class="example">          (REF) STRUCT i STRUCT j STRUCT k  ...  M
</pre>
     <p>where <code>param</code> is the number of i-structs before the mode M. 
The object is to be coerced to a param-dimensional (ref) array.

     <br><dt><code>xvec</code><dd>1 operand, a (ref) m to become a (ref) vector of <code>m</code>.

     <br><dt><code>xisvec</code><dd>1 operand, a (ref) i-struct to become a (ref) vector.

     <br><dt><code>xis</code><dd>1 operand, an object to become a <code>STRUCT 1 X</code> or a
<code>REF STRUCT 1 X</code> as given by <code>m</code>.  The mode of the operand is
<code>X</code> in the former case and <code>REF X</code> in the latter.

     <br><dt><code>xniltom</code><dd>1 operand, a <code>NIL</code> to be coerced to mode <code>m</code>.

     <br><dt><code>xvac</code><dd>1 operand, an <code>EMPTY</code> to be coerced to a vector or array.

     <br><dt><code>xmtoxtype</code><dd>1 operand, a (ref) m to be coerced to (ref) xtype.

     <br><dt><code>xytypetom</code><dd>1 operand, a (ref) ytype to be coerced to mode m.

     <br><dt><code>xskiptom</code><dd>1 operand, a <code>SKIP</code> to be coerced to mode <code>m</code>
(<code>m</code> /= <code>voidmode</code>).

     <br><dt><code>xgotoproc</code><dd>1 operand, a jump to be procedured to mode <code>m</code>.

     <br><dt><code>xgotom</code><dd>1 operand, a jump to be coerced to mode <code>m</code>.

     <br><dt><code>xvoid</code><dd>1 operand to be coerced to <code>voidmode</code>. 
</dl>

   <p>* The mode of the operand may be preceded by <code>SHORT</code> or <code>LONG</code> prefixes,
  in which case the mode of the result also starts in this way.

<h4 class="subsection"><a name="TOC68"></a>6.6.3 Field selection and array indexing</h4>

     <dl>
<dt><code>xselect</code><dd>      1 operand, a structure or array of structures from which
              the <code>param</code>th field must be selected (starting from 1).

     <br><dt><code>xsimpleindex</code><dd> 1 + <code>param</code> operands comprising an array or vector and
              param subscripts (1 for a vector) to produce a single
              array or vector element.

     <br><dt><code>xtrimindex</code><dd>   1 + <code>param</code> operands comprising an array or vector and
              param trimscripts (1 for a vector) to produce a subset
              of the array or vector.  If the operands are a vector
              and a trimmer containing <code>AT</code>, The result is an array.

     <br><dt><code>xtrim</code><dd><code>param</code> operands comprising none, some or all of <code>a</code>, <code>b</code> and
              <code>c</code> in <code>a:b AT c</code> to produce (a value for) the trimmer. 
              <code>m</code> = 1  if <code>a</code> is present
                + 2  if <code>b</code> is present
                + 4  if <code>AT c</code> is present
                + 8  if lower bound needs setting (to 1 or <code>c</code>)

</dl>
   Note: when selection or indexing operations are applied to a (single)
reference, the result is a reference.

<h4 class="subsection"><a name="TOC69"></a>6.6.4 Procedure calls</h4>

     <dl>
<dt><code>xparampack</code><dd><code>param</code> operands comprising the actual parameters of a
            procedure which is about to be called (if already on the
            stack) or loaded and then called (with no intervening
            imperative).  The values for the parameters must be
            removed from the stack, and there is no resulting value to
            be put on.

     <p><code>m</code> = the mode of the procedure for which the operands are
                the actual parameters.

     <br><dt><code>xcall</code><dd>     1 operand, a procedure.  The procedure must be called and
            a value for its result (mode <code>m</code>) put on the stack.

     <p><code>param</code> =
          <dl>
<dt>0<dd>when the procedure to be called is not a generator routine or an
operator
<br><dt>1<dd>for a call of an invented routine which generates dynamic local space
<br><dt>2<dd>for a call of an invented routine which generates dynamic space on the heap
<br><dt>3<dd>for a call of an invented generator routine occurring within another such generator routine
<br><dt>4<dd>for a call of a user-defined (or library) operator
</dl>
     </dl>

<h4 class="subsection"><a name="TOC70"></a>6.6.5 Assignment</h4>

     <dl>
<dt><code>xassign</code><dd>  2 operands, the destination and source for a simple
          assignment operation, which must be carried out leaving the
          value for the destination on the stack.  For assignments of
          fixed-size objects, <code>param</code> is 1.  For vector or array
          assignments (restricted to one dimension), the source
          will be a descriptor.  If the destination mode is a ref flex
          array or ref flex vector, <code>param</code> will be 1 and code must be
          generated to assign the descriptor only.  If the destination
          mode is a non-flex ref vector or ref array, <code>param</code> will be 2,
          and code must be generated to assign the elements, which
          will be objects of fixed size. 
</dl>

<h4 class="subsection"><a name="TOC71"></a>6.6.6 Space finding</h4>

     <dl>
<dt><code>xbdpack</code><dd>     <code>param</code> operands, which, if even in number, comprise the
            lower and upper bounds for each dimension of an array; if
            <code>param</code> is 1, the operand is the upper bound of a vector
            (for which the lower bound is always 1).  The operands on
            the stack are to be replaced by a value for the bound
        pack, used by <code>xdyngrab</code> Below.  For the operation <code>xbdpack</code>,
            <code>m</code> is undefined.

     <br><dt><code>xdyngrab</code><dd>  [always following <code>xbdpack</code> and load of a bool value inside
             an invented routine]
            2 operands, a bound pack and a value for a bool.  Code
            must be produced to generate the space for the elements
            of an array or vector, locally or on the heap according as
            the boolean at run time is true or false.  The operation
            <code>xdyngrab</code> delivers the descriptor of the array or vector,
            and <code>m</code> is its mode.

     <br><dt><code>xstatgrab</code><dd>  1 operand, the static part of a generated dynamic object
            of mode <code>X</code>, where <code>M</code> = <code>REF X</code>.  Code must be produced to
            create the space (if necessary) for the static part of
            the object, assign the operand to it and deliver the
            reference. 
            <code>param = ABS TRUE</code> or <code>ABS FALSE</code> for local or heap generation
            respectively.

     <br><dt><code>xcopy</code><dd>      [preparatory to <code>xassign</code> for a flex vector or flex array]
            1 operand, the descriptor of an array of any dimensions,
            or the descriptor of a vector.  Code must be produced to
            generate heap space and copy the elements of the array or
            vector into it.  The operation delivers the descriptor; <code>m</code>
            is the corresponding mode and <code>param = ABS FALSE</code>.

     <br><dt><code>xdefaultbd</code><dd> No operand.  The operation is to tuck, under the top item
            on the stack, a value for a default lower bound of 1,
            arising from constructions like <code>[n] INT</code> in the source
            text.  <code>m</code> is undefined.

</dl>

<h4 class="subsection"><a name="TOC72"></a>6.6.7 Straightening</h4>

     <dl>
<dt><code>xprestraight</code><dd> [preparatory to <code>xstraight</code> whenever necessary]
              1 operand, an object to be adjusted to have mode <code>m</code> in
              readiness for straightening, which is carried out by
              the operation <code>xstraight</code> described below.  The mode
              adjustment will entail provision of an initial ref, if
              the original object was not a reference, and will
              introduce <code>FLEX</code> as given in <code>m</code>, if not already present. 
              The resulting object, for which a value must be put on
              the stack, need exist only within the current scope.

     <br><dt><code>xstraight</code><dd>    2 operands, the <code>composite</code> and <code>index</code> fields for the
              <code>STRUCT</code> displayed below.  A straight of mode <code>m</code> must be
              constructed and a value for it put on the reverse Polish
              stack.  The <code>param</code> field gives information about the
              object to be straightened and is used as follows

          <dl>
<dt>1<dd>union
<br><dt><var>number of elements</var><dd>struct or i-struct
<br><dt>-1<dd>vector
<br><dt><var>-1-n</var><dd>array of n dimensions
</dl>

     <br><dt><code>xstrindex</code><dd>    2 operands, a straight, <code>s</code>, and an integer, <code>i</code> (say).  The
              operation gives rise to the procedure call

     <pre class="example">          (index OF s)(i, composite OF s)
</pre>
     <p>The result of this procedure is the <code>i</code>th member of the
              straight <code>s</code>, having mode <code>m</code>, and a value for it must be
              put on the reverse Polish stack.

</dl>

   <p>A straight, of mode <code>STRAIGHT X</code> (say), is a descriptor &mdash; distinct from
an array descriptor &mdash; containing a reference to the original composite
object.  It also contains a procedure which is provided by the
compiler for indexing, and an integer for the number of members of the
straight.  Thus a straight descriptor is likely to have the form

<pre class="example">     STRUCT (REF COMP composite, PROC (INT, REF COMP) X index, INT upb)
</pre>
   <p>where <code>COMP</code> is the original row, vector, struct, i-struct or union mode
(but with <code>FLEX</code> introduced wherever applicable).

<h3 class="section"><a name="TOC73"></a>6.7 The Control Imperatives (<code>XCONTROL</code>)</h3>

<p>The mode <code>XCONTROL</code> is defined as
<pre class="example">     MODE  XCONTROL  =  STRUCT (INT fn, m, BITS props, INT param);
</pre>
     <dl>
<dt><code>fn</code><dd>Distinguishes the various <code>XCONTROL</code>s, as listed below, and reflects the
structure of Algol 68 in stream language.

     <br><dt><code>m</code><dd>In an <code>XCONTROL</code> at the start of a serial clause (or an enquiry clause, or
the remainder of a serial clause after an <code>EXIT</code> in the source text), the
<code>m</code> field gives the mode of the result of the clause.  The mode number is
negated when the result of the closed clause is also the result of the
surrounding serial clause.  <code>m</code> is defined only where indicated in the table
below.

     <br><dt><code>props</code><dd>The letters in the table refer to properties detailed on the next section,
which are concerned with the implementation of lifetimes and the handling of
results.  Furthermore, any <code>XCONTROL</code> generated by the compiler has the
<code>compgenbit</code> set.

     <br><dt><code>param</code><dd>Additional information, defined in the following section. 
</dl>

<h4 class="subsection"><a name="TOC74"></a>6.7.1 Fields of an <code>XCONTROL</code></h4>

     <dl>
<dt><code>xcase</code>, etc [1]<dd><code>m</code> defined; <code>props = a</code>; <code>param = </code> mode of result of
closed clause [7]

     <br><dt><code>xin</code>, etc [2]<dd><code>m</code> defined;<code>props = a b</code>;<code>param = </code> total number of cases [8]

     <br><dt><code>xcomma</code>, etc [3]<dd><code>m</code> defined; <code>props = a b e [6]</code>;<code>param = </code> case no of ensuing serial clause

     <br><dt><code>xwhile</code>, <code>xdo</code> [4]<dd><code>m</code> defined;<code>props = a</code>; <code>param = </code>  mode of result of closed clause

     <br><dt><code>xesac</code>, etc [5]<dd><code>props = b</code>; <code>param = </code>  undefined

     <br><dt><code>xroutinend</code><dd><code>props =  b g</code>; <code>param = </code>  undefined

     <br><dt><code>xsemi</code><dd><code>props = s</code>; <code>param = </code>  undefined

     <br><dt><code>xexit</code><dd><code>m</code> defined;<code>props =  b</code>;<code>param = </code>  first exit in a serial clause is
                                  treated like an <code>xin</code>, subsequent
                                  exits like <code>xcomma</code>

     <br><dt><code>xfinish</code><dd> the final imperative from a successful compilation

</dl>

   <p><strong>Notes</strong>
     <dl>
<dt>1<dd>closed clause starters: <code>xbegin</code>, <code>xif</code>, <code>xcase</code>, <code>xcaseu</code>,
<code>xcoll</code>
<br><dt>2<dd>  <code>xthen</code>, <code>xin</code>, <code>xinu</code>
<br><dt>3<dd>  serial clause separators: <code>xelse</code>, <code>xcomma</code>, <code>xout</code>,
<code>xcommau</code>, <code>xoutu</code>, <code>xcollcomma</code>
<br><dt>4<dd>  if <code>xwhile</code> is present, it is the closed clause starter; otherwise
   <code>xdo</code> is the closed clause starter
<br><dt>5<dd>  closed clause terminators: <code>xend</code>, <code>xfi</code>, <code>xesac</code>, <code>xesacu</code>,
<code>xendcoll</code>, <code>xod</code> (which is immediately preceded by an <code>xsemi</code>, so
bit <code>b</code> will in this case be absent). 
<br><dt>6<dd>  this property applies to <code>xelse</code>, <code>xout</code> and <code>xoutu</code> only. 
<br><dt>7<dd> the mode number is negated when the result of the closed clause is
   also the result of the surrounding closed clause
<br><dt>8<dd>  in an if clause, then and else count as "cases" 1 and 2; in a case
   clause with an out part, the <code>param</code> field at the <code>xin</code> is minus the
   number of cases between in and out. 
</dl>

<h4 class="subsection"><a name="TOC75"></a>6.7.2 The <code>props</code> field of an <code>XCONTROL</code></h4>

<p>As with the corresponding field of <code>XROUTINE</code>, the props field is made
up as a conjunction of bits values of the form <var>2**n</var>.  These are
denoted mnemonically (eg <code>iddbit</code>), and represent attributes of the
context at which they are given.  The contexts (a, b, s, e, g) are
those given in the above table.  Bits not mentioned for a particular
context (or bits of the <code>props</code> field which have no mnemonics) must be
assumed undefined.

<h5 class="subsubsection"><a name="TOC76"></a>6.7.2.1 General preliminary information</h5>

<p>The meaning of individual bits is as follows
     <dl>
<dt><code>priobit</code><dd>an Algol 68 priority declaration in the source text
<br><dt><code>semibit</code><dd>semicolon
<br><dt><code>decbit</code><dd>an Algol 68 declaration (except priority)
<br><dt><code>vardecbit</code><dd>an <code>xvardec</code> or <code>xivardec</code>
<br><dt><code>labbit</code><dd>a label setting
<br><dt><code>exitbit</code><dd>an <code>EXIT</code>
<br><dt><code>locgenbit</code><dd>an explicit local generator
<br><dt><code>locdydecbit</code><dd>a declaration containing a dynamic part
</dl>

<h5 class="subsubsection"><a name="TOC77"></a>6.7.2.2 Dynamic result bits</h5>

<p>Table <code>a</code>

   <p>Presence of bit means that the following serial clause contains a
discarded dynamic result <small class="dots">...</small>
     <dl>
<dt><code>dyprocbit</code><dd><small class="dots">...</small> from a procedure
<br><dt><code>dyvardecbit</code><dd><small class="dots">...</small> from a closed clause containing an <code>xvardec</code> or an <code>xivardec</code>
<br><dt><code>dydecbit</code><dd><small class="dots">...</small> from a closed clause containing an Algol 68 declaration in the source-text
</dl>

   <p>Table <code>b</code>

   <p>Presence of bit means <small class="dots">...</small>
     <dl>
<dt><code>dontpullbit</code><dd><small class="dots">...</small> that there is a dynamic result from the preceding
                   serial clause (or part of serial clause before an
                   <code>EXIT</code>)
</dl>

   <p>Table <code>s</code>

   <p>Presence of bit means (at an <code>xsemi</code> only) <small class="dots">...</small>
     <dl>
<dt><code>dontpullbit</code><dd><small class="dots">...</small> that the preceding phrase was a declaration
<br><dt><code>dyprocbit</code><dt><code>dyvardecbit</code><dt><code>dydecbit</code><dd><small class="dots">...</small> that a dynamic result can now be discarded unless the <code>dontpullbit</code> is
also present
</dl>

<h5 class="subsubsection"><a name="TOC78"></a>6.7.2.3 Routine bits</h5>

<p>Table <code>g</code>

   <p>Presence of bit means that <small class="dots">...</small>

     <dl>
<dt><code>genprocbit</code><dd><small class="dots">...</small> the foregoing routine was an invented generator routine
<br><dt><code>globscopebit</code><dd><small class="dots">...</small> the foregoing routine was an invented
                   assignment or straightening routine that used no
                   non-local names
<br><dt><code>valbit</code><dd><small class="dots">...</small> the foregoing routine is to be loaded
                   onto the reverse Polish stack; there is no <code>XLOAD</code>
                   following

   </dl>

   <p>Table <code>e</code>

   <p>Presence of bit means that <small class="dots">...</small>
     <dl>
<dt><code>elifousebit</code><dd><small class="dots">...</small> <code>xelse</code>, <code>xout</code> or <code>xoutu</code> are derived from
                   elided source-text constructions <code>ELIF</code> or <code>OUSE</code>

   </dl>

<h4 class="subsection"><a name="TOC79"></a>6.7.3 Other control imperatives</h4>

<p>Introduces a do-statement.  Values for the <code>FROM</code>, <code>BY</code> and <code>TO</code>
parts (if any) will have been loaded, in that order.

     <dl>
<dt><code>m</code><dd>undefined

     <br><dt><code>props</code><dd>
          <dl>
<dt>1<dd>if an identifier has been given for the loop counter,
               in which case the next imperative will be an <code>XIDDEC</code>
               for the identifier with type <code>xfordec</code>
<br><dt>+2<dd>if a value for <code>FROM</code> is present
<br><dt>+4<dd>if a value for <code>BY</code> is present
<br><dt>+8<dd>f a value for <code>TO</code> is present
</dl>

     <br><dt><code>param</code><dd>gives the number of values on the stack
</dl>

<h5 class="subsubsection"><a name="TOC80"></a>6.7.3.1 <code>fn</code> = <code>xforall</code></h5>

<p>Introduces a forall-statement.  Values for the arrays or vectors to be
sequenced through will have been loaded, in the order in which they
were given in the source text.

     <dl>
<dt><code>m</code><dd>undefined
<br><dt><code>props</code><dd>undefined
<br><dt><code>param</code><dd>the number of values on the stack
</dl>

   <p>The <code>xforall</code> imperative will be followed by a series of <code>xiddec</code>
imperatives for the identifiers declared by the <code>forall</code> statement. 
Each of these refers to the array or vector value on top of the
stack, which must be removed.

<h5 class="subsubsection"><a name="TOC81"></a>6.7.3.2 <code>fn</code> = <code>xuchoice</code></h5>

<p>Occurs immediately after an <code>xinu</code> or <code>xcommau</code> (except for the
possibility of intervening labels), and represents the declarer in
a choice.

     <dl>
<dt><code>m</code><dd>mode of the declarer
<br><dt><code>props</code><dd>setting of the <code>decbit</code> indicates that a formal
               identifier has been given, in which case the next
               imperative will be an <code>XIDDEC</code> for the identifier, with
               type <code>xccdec</code>
<br><dt><code>param</code><dd>the serial number of <code>m</code> in the union mode under test
               (say <code>n</code>), or <code>-n</code> if <code>m</code> is itself a union
</dl>

<h3 class="section"><a name="TOC82"></a>6.8 The <code>XWARN</code> Imperative</h3>

<p>The <code>XWARN</code> imperative gives advance warning of various stream language
imperatives.  Most of these are certain types of dyadic operation,
for which the <code>XWARN</code> is given between the loading of the two operands
and is additional to the <code>XOPER</code> which will come when both operands have
been loaded.  <code>XWARN</code> has the form

<pre class="example">     MODE  XWARN  =  STRUCT (INT w)
</pre>
   <p>where <code>w</code> takes one of the mnemonic values specified below
indicating what operation is being forewarned.

     <dl>
<dt><code>xwass</code><dd><code>xassign</code> operation
<br><dt><code>xwandth</code><dd><code>xdyop</code> operation <code>ANDTH</code> (see Appendix 1)
<br><dt><code>xworel</code><dd><code>xdyop</code> operation <code>OREL</code> (see Appendix 1)
<br><dt><code>xwindex</code><dd><code>xsimpleindex</code>, <code>xtrimindex</code>, <code>xtrim</code> and <code>xstrindex</code> operations
<br><dt><code>xwplusabetc</code><dd><code>xdyop</code> operations <code>PLUSAB</code>, <code>MINUSAB</code>, <code>TIMESAB</code>, <code>OVERAB</code>,
                 <code>MODAB</code> and <code>DIVAB</code>
<br><dt><code>xwforall</code><dd>forall-statement.  The warning occurs after each loading of a vector or an array
<br><dt><code>xwloop</code><dd>for-statement.  The warning occurs at the beginning,
                 ie before the loading of the <code>FROM</code>, <code>BY</code> or <code>TO</code> parts if
                 present

   </dl>

<h3 class="section"><a name="TOC83"></a>6.9 The <code>XPRAG</code> Imperative</h3>

<p>This is defined as

<pre class="example">     MODE  XPRAG  =  STRUCT (BOOL all, REF VECTOR [] CHAR pr)
</pre>
   <p>where <code>pr</code> refers to a vector containing the first line of a pragmat
in the source-text.  The <code>all</code> field is <code>TRUE</code> if <code>pr</code> contains the whole
of the pragmat, otherwise <code>FALSE</code>.  If the first line contains an
opening comment symbol, <code>pr</code> will contain only the characters preceding
the comment symbol.

<h3 class="section"><a name="TOC84"></a>6.10 The <code>XCHARPOS</code> Imperative</h3>

<p>The <code>XCHARPOS</code> imperative allows the shell to keep track of the character
position within a line of Algol 68 source-text.  It is defined as

<pre class="example">     MODE  XCHARPOS  =  STRUCT (INT charpos)
</pre>
   <p>where <code>charpos</code> indicates the character position of a significant
symbol.  Such information may be required for diagnostic purposes. 
The <code>XCHARPOS</code> imperative will normally be output so that when read back,
it immediately precedes an <code>XCONTROL</code>; the significant symbol will be the
source-text analogue of the <code>XCONTROL</code>.  However, if the <code>XCONTROL</code> is a
closing control, there may be coercions between the <code>XCHARPOS</code> and the
<code>XCONTROL</code>.

   <p>The imperatives <code>xfor</code> and <code>xforall</code> are not output at positions
corresponding to the <code>FOR</code> and <code>FORALL</code> symbols; for these the symbol
position is output preceding the <code>XWARN (Xwloop)</code>.  A symbol position is
also output before an <code>XROUTINE</code> imperative and an <code>XLABDEC</code> (where
<code>notsetting = FALSE</code>).

<h3 class="section"><a name="TOC85"></a>6.11 An example of stream language</h3>

<pre class="example">      0    PROGRAM  p10
      1    CONTEXT  VOID
      2    BEGIN  INT i;   INT k = 80;
      3           REAL rrr := 2.34e5;
      4           MODE V = VECTOR [3] INT;
      5           V v := (k, i, ENTIER rrr);
      6           FLEX V fv := v;
      7
      8           PROC p = (INT n) INT:
      9           IF  n &gt; 0
     10           THEN  n * (v[n] - i)
     11           ELSE  0
     12           FI;
     13
     14           p(i := -4)
     15    END
     16    FINISH
</pre>
   <p>When the above program is compiled by the RS compiler, the following
stream language is obtained:

<h4 class="subsection"><a name="TOC86"></a>6.11.1 Sizes</h4>

<p>module contains 130 outputs, 2 routines, 35 modes, 1 labels,
                    11 identifiers, 1 modules and 0 libinds

<h4 class="subsection"><a name="TOC87"></a>6.11.2 Modes</h4>

<pre class="example">     31   VECTOR [] INT
     32   PROC  ( BOOL ) 31
     33   STRUCT  3  INT
     34   FLEX  VECTOR [] INT
     35   PROC  ( INT )  INT
</pre>
<h4 class="subsection"><a name="TOC88"></a>6.11.3 Other imperatives</h4>

<pre class="example">              xtdtype(902)
     2:       begin(5, 8r361, 5)
     3:       dummydec(0, 4, " anonymous")    vardec(1039, 5, "i")
              semi(0, 8r4000, 0)    number(15, "a80")    iddec(15, 6, "k")
     4:       semi(0, 8r4000, 0)    number(19, "r2d34p5")
              ivardec(1043, 7, "rrr")
     5:       semi(0, 8r4000, 0)
              vardec(1056, 8, " anonymous")
              load(8)      warn-assign
     
              routine(1001, 32, 32778, 8, " generator")
              fdec(7, 9, " anonymous")
              begin(31, 8r420, 31)    number(15, "a3")    bdpack(0, 1)
              load(9)    dyngrab(31, 0)
              end(0, 8r4400, 31)
              endrd(0, 8r100410, 0)
     
              assign(1056, 1)    void(5, 0)    semi(0, 8r400, 0)
     6:       semi(0, 8r4000, 0)    load(8)    deref(32, 0)    true
              ppack(32, 1)    call(31, 1)
              ivardec(1055, 9, "v")
              semi(0, 8r4000, 0)    load(9)    warn-assign
              coll(15, 8r41, 33)    load(6)
              collcomma(15, 8r41, 2)    load(5)    deref(15, 0)
              collcomma(15, 8r41, 3)    load(7)    deref(19, 0)
              monop(15, 209)
              endcoll(0, 8r0, 33)    isvec(31, 0)    assign(1055, 2)
              void(5, 0)    semi(0, 8r0, 0)
     7:       semi(0, 8r4000, 0)    load(8)    deref(32, 0)    true
              ppack(32, 1)
              call(34, 1)
              ivardec(1058, 10, "fv")
              semi(0, 8r4000, 0)    load(10)    warn-assign     load(9)
              deref(31, 0)    copy(31, 0)    assign(1058, 1)    void(5, 0)
              semi(0, 8r0, 0)
     9:       semi(0, 8r4000, 0)
     
              routine(1002, 35, 2, 9, "p")
              fdec(15, 11, "n")
     10:      if(7, 8r41, 15)    load(11)
     11:      number(15, "a0")    diop(7, 114)
              then(15, 8r41, 2)    load(11)    load(9)    warn-index
              load(11)    simpleindex(1039, 1)    deref(15, 0)    load(5)
              deref(15, 0)
              diop(15, 17)
     12:      diop(15, 194)
              else(15, 8r41, 2)    number(15, "a0")
     13:      fi(0, 8r0, 15)
              endrd(0, 8r0, 0)
     
     15:      semi(0, 8r4000, 0)    load(1002)    load(5)    warn-assign
              number(15, "a4")    monop(15, 17)    assign(1039, 1)
              deref(15, 0)
     16:      ppack(35, 1)    call(15, 0)    void(5, 0)
              end(0, 8r0, 5)
              finish(0, 8r0, 0)
</pre>
   <p>The above is merely a visual representation of the output from a
`standard' shell.  The <code>XEDIT</code> imperatives have been absorbed in
order to produce a continuous series of other imperatives.

<!-- ***************************************************************** -->
<!-- PART C - MODULAR COMPILATION -->
<!-- ***************************************************************** -->
<h2 class="chapter"><a name="TOC89"></a>7 Introduction</h2>

<p>A program can be compiled in portions known as modules, of which there
are three different types.  The basic type is the <dfn>closed clause</dfn> or <dfn>cc</dfn>
module which consists of an Algol 68 closed clause with a suitable
heading and the word <code>FINISH</code>.  This could be a complete program or one
of a number of cc modules which are to be nested one within another. 
In the actual Algol text of a cc module, any place at which some
inner module is later to be inserted is marked by a new type of
unitary clause known as a <dfn>here-clause</dfn>.

   <p>A nest of modules will be described as a <dfn>composition</dfn>.  The selection
and placement of modules to make a composition is specified in a
composition module, which contains no Algol 68 text of its own.  A
composition need not be completed all at once.  A program can be
partially composed in one composition module, leaving spaces for
further cc modules to be inserted later on by other composition
modules.

   <p>A third type of module, the <dfn>declarations</dfn> module, enables modes,
procedures and other items to be declared and compiled in advance of
their use in other modules.  Declarations modules are used in a very
straightforward way requiring no composition, but they can never make
a program by themselves.  To make this distinction clear, the other
types of module (cc and composition) will be described as program
modules.

<h2 class="chapter"><a name="TOC90"></a>8 The Source Language</h2>

<h3 class="section"><a name="TOC91"></a>8.1 keeplists</h3>

<p>Interaction between modules demands that source-text indicators
(identifiers, modenames and operators) declared in one module shall
be usable with the same meanings in another module.  The source-text
of a module must always specify which of its indicators are to be
kept after compilation for use in modules to be compiled later.  A
keeplist is a sequence of such indicators, separated by commas.  To
distinguish between versions of operators, the modes of operands
must always be included, as in the keeplist here:

<pre class="example">     MAN, WOMAN, = (MAN, WOMAN), = (WOMAN, MAN), adam, eve
</pre>
   <p>The order of the items in a keeplist is never significant.

<h3 class="section"><a name="TOC92"></a>8.2 Simple declarations modules</h3>

<p>The sole purpose of a declarations module is to make declared items
available for use in other modules.  Consequently, a declarations
module must invariably have a keeplist for such items, and if it uses
no indicators from other modules itself (other than from automatically
incorporated library modules), its form is

<pre class="example">     DECS decstitle:
     body
     KEEP keeplist
     FINISH
</pre>
   <p>In the first line, <code>decstitle</code> stands for an identifier chosen to be the
title of the module.  The body is not enclosed in <code>BEGIN</code>-<code>END</code> brackets
but is introduced by a colon.  It consists of Algol 68 declarations
and other phrases which may be convenient for setting things up. 
Certain restrictions are enforced to ensure that declarations modules
can be obeyed in any order without giving rise to side-effects.  Thus
no procedures or user-defined operators may be called, except within
routine texts.  Also, no labels may be declared in the outermost
level.  These are the only restrictions for a self-sufficient
declarations module, but we must now turn attention to a more general
class of module which has an added restriction.

   <p>A <code>DECS</code> module can use indicators kept from previously compiled <code>DECS</code>
modules. There are two requirements for the passage of an item from
one module to another.  Its indicator must be included in the keeplist
of the source module and the title of that module must be included in
the heading of the using module, as shown in the second line below:

<pre class="example">     DECS decstitle
     USE decstitlelist:
     body
     KEEP keeplist
     FINISH
</pre>
   <p>The <code>decstitlelist</code> is simply a list of the titles of all the other <code>DECS</code>
modules required, separated by commas.  The body can now use kept
items from these modules, with one further restriction to ensure
complete absence of side-effects.  No kept item which is a reference
(or a structure, array or union containing a reference) may be used,
except within a routine text.  These restrictions on the use of
external references and calls of procedures or user-defined operators
are peculiar to <code>DECS</code> modules and free the user from having to consider
at what stage his <code>DECS</code> modules are actually obeyed.

<h3 class="section"><a name="TOC93"></a>8.3 Simple Programs</h3>

<p>Simple programs will usually consist of one closed clause module,
possibly supported by previously compiled declarations modules.  Using
square brackets to indicate this option, the form in which the cc
module is written is:

<pre class="example">     PROGRAM progtitle
     [ USE decstitlelist ]
     closed clause
     FINISH
</pre>
   <h3 class="section"><a name="TOC94"></a>8.4 Nested Modules</h3>

<p>Within any program module, a place can be held for a separately
compiled program module to be inserted later.  This is done by the
new unitary clause

<pre class="example">     HERE place(keeplist)
</pre>
   <p>where <code>place</code> stands for some identifier to name the place, and the
keeplist contains any indicators currently in scope which are to be
kept for the of the inserted program module.  If there are several
<code>HERE</code> clauses in the same module, the place identifiers must all be
distinct.

   <p>The form of a cc module which contains <code>HERE</code>-clauses is similar to that
of the simple program shown in C2.3, except that each place defined
in a <code>HERE</code>-clause must also be listed in the module heading before the
title, ie

<pre class="example">     PROGRAM (placelist) progtitle
     [ USE decstitlelist ]
     closed clause including HERE-clauses
     FINISH
</pre>
   <p>The places in the placelist are listed, with comma separation, in any
order.

   <p>A simple cc module suitable for insertion at a given place would be

<pre class="example">     PROGRAM title
     [ CONTEXT place IN progtitle ]
     closed clause
     FINISH
</pre>
   <p>The <code>CONTEXT</code> part of the heading, if present, makes the keeplist at the
given place accessible in the closed clause.  It also prevents the
module being used in any other context.        (By contrast, a module with
no context specification could be inserted at any place, but would be
denied access to the associated keeplist.  This may seem a pointless
construction, but a realistic example of its use is given in C2.7.)

   <p>Example of nesting

<pre class="example">     PROGRAM (detail) frame
     BEGIN MODE FORM = ... ;
           OP CONV = (FORM f)INT: ... ;
           FORM f1, f2, g1, g2;
           - - -
           HERE detail(FORM, CONV(FORM), g2);
           - - -
     END
     FINISH
     
     PROGRAM  insert
     CONTEXT  detail IN frame
     BEGIN  FORM f := g2;
            INT n := CONV f;
            - - -
     END
     FINISH
</pre>
   <p>Although <code>insert</code> is compiled in the context of the first module so as
to pick up its kept indicators, it remains a separate module.  A
program combining the two modules has to be expressed as a composition
module,

<pre class="example">     PROGRAM whole
     COMPOSE frame(detail = insert)
     FINISH
</pre>
   <h3 class="section"><a name="TOC95"></a>8.5 Composition</h3>

<p>The purpose of a composition module is to assemble a nest of modules
by pairing up formal place names (the ones in the Algol 68 <code>HERE</code>
clauses) with actual names of program modules.

   <p>The form of module which completes a nesting, inwards from some given
starting module <code>x</code>, say, is

<pre class="example">     PROGRAM progtitle
     COMPOSE nest
     FINISH
</pre>
   <p>where <code>progtitle</code> is a new identifier to act as the title of the
composition and nest starts with the title, <code>x</code>, of the starting module,
continuing with a bracketed list of substitutions having a place on
the left and on the right a further nest or the name of a program
module.

<h4 class="subsection"><a name="TOC96"></a>8.5.1 Example</h4>

<p>Given a program module starting

<pre class="example">     PROGRAM (x1, x2) x
</pre>
   <p>and a set of inner modules with the headings

<pre class="example">     PROGRAM a
     CONTEXT x1 IN x
     
     PROGRAM (b1, b2, b3) b
     CONTEXT x2 IN x
     
     PROGRAM (c1) c
     CONTEXT b1 IN b
     
     PROGRAM d
     CONTEXT b2 IN b
     
     PROGRAM e
     CONTEXT b3 IN b
     
     PROGRAM f
     CONTEXT c1 IN c
</pre>
   <p>the following composition module combines them all into one:

<pre class="example">     PROGRAM compo
     COMPOSE x(x1 = a,
               x2 = b(b1 = c(c1 = f),
                      b2 = d,
                      b3 = e))
     FINISH
</pre>
   <p>This composition module may still not be a complete runnable program,
for <code>x</code> may specify some context.  If so, it will obviously apply to
<code>compo</code> as well.  Composition modules cannot have context
specifications in their headings; the context which applies to such
a module is that specified in its outermost cc module.

<h3 class="section"><a name="TOC97"></a>8.6 Partial Composition</h3>

<p>A composition module may leave some places to be filled by other
program modules in a further composition later.  It does this by
pairing a place name with a new place name of its own instead of an
actual program module title.  A new place name in a composition module
is introduced by the word <code>HERE</code>, even though it is not in an Algol text
setting.  As an example, let us omit module <code>c</code> from the composition
given above, and make the partial composition

<pre class="example">     PROGRAM (hole) p
     COMPOSE x(x1 = a,
               x2 = b(b1 = HERE hole,
                      b2 = d,
                      b3 = e))
     FINISH
</pre>
   <p>Observe that there is no explicit keeplist at <code>HERE</code> in a partial
composition.  The available indicators are all those kept en route
from the outermost module to the word <code>HERE</code> in the composition.  Thus,
any module now compiled at

<pre class="example">     CONTEXT hole IN p
</pre>
   <p>has available to it all the indicators kept at <code>x2</code> in <code>x</code>, as well as
those at <code>b1</code> in <code>b</code>.  Combination of keeplists is the main purpose
of partial composition, enabling programs to exploit several
`environmental packages' simultaneously, as we shall now see.

<h3 class="section"><a name="TOC98"></a>8.7 Use of environmental packages</h3>

<p>Many packages (eg for simulation or graph-plotting), besides declaring
modes and procedures, have to set up some starting position before the
user's program is obeyed, and tidy up afterwards (eg close files which
were opened at the start).  The basis of any such package must be a cc
module with a <code>HERE</code> for the rest of the program.

   <p>For instance,

<pre class="example">     PROGRAM (userprog) package1
     BEGIN - - -;
           - - -;
           HERE userprog(keeplist1);
           - - -;
           - - -
     END
     FINISH
     
     PROGRAM myprog
     CONTEXT userprog IN package1
     closed clause
     FINISH
</pre>
   <p>with

<pre class="example">     PROGRAM runner
     COMPOSE package1(userprog = myprog)
     FINISH
</pre>
   <p>as the composition.

   <p>Now consider writing a program, <code>ourprog</code> say, which requires the
services of two packages, designed independently along the lines of
<code>package1</code>.  The question will be, in what context to compile <code>ourprog</code>? 
It cannot be <code>userprog IN package1</code>, which brings in only <code>keeplist1</code>, nor
can it be <code>userprog IN package2</code> for a similar reason.  The only answer
is a context like <code>user IN both</code>, set up specially by the partial
composition:

<pre class="example">     PROGRAM (user) both
     COMPOSE package1(userprog = package2(userprog = HERE user))
     FINISH
</pre>
   <p>The context <code>user IN both</code> combines the keeplists of both packages, as
explained in C2.6.  Before leaving this example, it is worth remarking
that <code>package2</code> fits at <code>userprog IN package1</code> because <code>package2</code>
specifies no particular context.  Being an independent package, it
needs no access to <code>package1</code>'s keeplist.

<h3 class="section"><a name="TOC99"></a>8.8 Declarations Modules In A Context</h3>

<p><code>DECS</code> modules, like cc modules, can specify a context in their heading:

<pre class="example">     DECS decstitle
     CONTEXT place IN progtitle:
     body using kepts at above place
     FINISH
</pre>
   <p>The <code>CONTEXT</code> line makes the kepts at <code>place IN progtitle</code> accessible
for use in the body of the <code>DECS</code> module, with the same restrictions
as given in C2.2 earlier.  No kept item which is a reference (or a
structure, array or union containing a reference) may be used except
within routine texts.  And as with all <code>DECS</code> modules, there can be no
procedure calls, or calls of user-defined operators.

   <p>Any module which has access to the same kepts (ie those at <code>place IN
progtitle</code>) can <code>USE</code> this declarations module.  The context specified
by the using module must therefore be the same as that of the <code>DECS</code>
module or be a dependent context resulting from partial composition &mdash;
which, by the combination rule, would supply the same kepts and more
besides.  To see this clearly, consider once more the composition

<pre class="example">     PROGRAM (hole) p
     COMPOSE x(x1 = a,
               x2 = b(b1 = HERE hole,
                      b2 = d,
                      b3 = e))
     FINISH
</pre>
   <p>The context <code>hole IN p</code> is derived from <code>b1 IN b</code> which is in turn
derived from <code>x2 IN x</code>.  It follows that any module specifying
<code>CONTEXT hole IN p</code> can <code>USE</code> declaration modules specifying one of
<code>hole IN p</code>, <code>b1 IN b</code>, <code>x2 IN x</code>, or, of course, no context at all.

<h3 class="section"><a name="TOC100"></a>8.9 Provision For ALGOL 68 Standard Environment</h3>

<p>Any cc module or declarations module having no explicit context
specification in its heading is assumed by the compiler to have
specified a standard default context.  For descriptive purposes only,
we shall refer to this as

<pre class="example">     CONTEXT %program IN %stdprelude
</pre>
   <p>Thus, a program which appears to be complete, such as

<pre class="example">     PROGRAM pmw
     closed clause
     FINISH
</pre>
   <p>can only be run when nested in <code>%stdprelude</code>.  The intention is that
the necessary composition should be effected automatically.  The
<code>%stdprelude</code> will go some part of the way towards providing the Algol
68 standard environment and will do so without any action by the user. 
(Its kepts are accessible to all modules without need for partial
composition, see 2.10.)

   <p>The remainder of the standard environment will be provided by library
<code>DECS</code> modules.  With the cooperation of its shell, the compiler will
supply a default <code>USE</code> for any library declarations modules required in
a program.

<h3 class="section"><a name="TOC101"></a>8.10 The <code>VOID</code> Context</h3>

<p>A truly outermost cc module specifies <code>CONTEXT VOID</code> and is, by that
token, a prelude.  (Absence of any context specification, as we have
already seen, does not imply a void context.)  The compiler treats
preludes in a special way.  For simplicity of explanation, it will
be assumed that a prelude has only one <code>HERE</code> clause.

   <p>The first special property of a prelude is that it provides what may
be described as a <em>universal context</em> for composition purposes. 
A cc module which specifies a prelude context (explicitly or by
default) can be inserted directly in the prelude or in any dependent
context.  An example of this is to be found at the end of C2.7
(environmental packages).

   <p>The second property of a prelude is that its kepts are universal.  Its
own keeplist and those of any <code>DECS</code> modules compiled at that context
are freely accessible to all dependent modules.  This is shown below
for a chain of cc modules.

<pre class="example">     PROGRAM (prog) ownprelude
     CONTEXT VOID
     closed clause
     FINISH
</pre>
   <p>can accept cc keeplists from nowhere.

<pre class="example">     PROGRAM (a1) a
     CONTEXT prog IN ownprelude
     closed clause
     FINISH
</pre>
   <p>can accept cc keeplists from <code>prog IN ownprelude</code>.

<pre class="example">     PROGRAM (b1) b
     CONTEXT a1 IN a
     closed clause
     FINISH
</pre>
   <p>can accept cc keeplists from <code>prog IN ownprelude</code> and <code>a1 IN
a</code>.

<pre class="example">     PROGRAM c
     CONTEXT b1 IN b
     closed clause
     FINISH
</pre>
   <p>can accept cc keeplists from <code>prog IN ownprelude</code> and <code>b1 IN b</code>.

   <p>The last of these modules, <code>c</code>, shows the accessible kepts to be those
from the immediately surrounding context and the outermost one.  The
keeplist at <code>a1 IN a</code> is <em>not</em> accessible.

   <p>Declarations modules, like cc modules, can be compiled at <code>CONTEXT VOID</code>. 
Any module can <code>USE</code> such a <code>DECS</code> module.  This is a consequence
of the general rule given in C2.8, and in fact the limiting case of it.

   <p>Finally, the context for a composition will be <code>VOID</code> if the composition
starts from a prelude.  This means that systems programmers will be
able to modify <code>%stdprelude</code> if they wish, without losing any of its
special properties.

<h3 class="section"><a name="TOC102"></a>8.11 Summary Of Syntax And Semantics Of Modules</h3>

<h4 class="subsection"><a name="TOC103"></a>8.11.1 <code>DECS</code> Module</h4>

<pre class="example">     DECS decstitle
     [ CONTEXT place IN progtitle ]*
     [ USE decstitlelist ]
     :
     body
     KEEP keeplist
     FINISH
</pre>
   <p>Except within routine texts, the body must not use any externally
    declared references or call any procedures or user-defined
    operators.

<h4 class="subsection"><a name="TOC104"></a>8.11.2 <code>PROGRAM</code> Modules</h4>

<pre class="example">     PROGRAM [ (placelist) ] progtitle
     [ CONTEXT place IN progtitle ]*
     [ USE decstitlelist ]
     closed clause
     FINISH
</pre>
   <p>The above is a closed clause or cc module.  The closed clause can
    include <dfn>here-clauses</dfn> of the form <code>HERE place(keeplist)</code>.  This
    makes a hole which can be filled by another cc module, as
    specified in a composition module:

<pre class="example">     PROGRAM [ (placelist) ] progtitle
     COMPOSE nest
     FINISH
</pre>
   <h4 class="subsection"><a name="TOC105"></a>8.11.3 Notes</h4>

<p><code>decstitle</code>, <code>place</code> and <code>progtitle</code> all stand for identifiers. 
An itemlist is a sequence of items with comma separation.  For the definition
of a keeplist, see C2.1.  For definition of nest, see C2.5.

   <p>* Omission of an explicit context introduces the default context:

<pre class="example">     CONTEXT %program IN %stdprelude
</pre>
   <p>For absolutely no context at all, <code>CONTEXT VOID</code> must be written.

<h3 class="section"><a name="TOC106"></a>8.12 Composition Rules</h3>

<p>A program module can be composed at <code>p IN q</code> if its context
specification (explicitly or by default) is one of the following
three possibilities

     <ul>
<li><code>p IN q</code>
<li>the prelude context from which <code>q</code> is derived
<li><code>VOID</code> (applicable only to prelude writers)
</ul>

   <p>The context specification of a composition module is that of its
starting module.

<h3 class="section"><a name="TOC107"></a>8.13 Accessibility Of Kepts For Use In A Cc Module</h3>

<p>If the context specification is <code>CONTEXT p IN q</code>, the cc module can use
kept indicators from

     <ul>
<li><code>p IN q</code> and any <code>DECS</code> compiled at <code>p IN q</code>
<li>if <code>q</code> is a partial composition, from any hierarchical context
embracing <code>p</code>, and any <code>DECS</code> compiled at any of those contexts
<li>the prelude context of <code>q</code> and any <code>DECS</code> compiled there
<li>any <code>DECS</code> compiled at context <code>VOID</code>
</ul>

   <p>Any DECS modules required must be mentioned in the heading of
the using module (in <code>USE decstitlelist</code>), unless they are library
<code>DECS</code> which may be incorporated in the final program automatically as
needed.

<h3 class="section"><a name="TOC108"></a>8.14 Accessibility Of Kepts For Use In A DECS Module</h3>

<p>The sources are the same as for cc modules, but any kept references
are debarred from use in the body of the <code>DECS</code> module except within
routine texts.  This restriction extends to objects such as
structures, arrays and unions containing references.

<h2 class="chapter"><a name="TOC109"></a>9 Stream Language</h2>

<p>This chapter may be regarded as a continuation of B3, which specified
the details of stream language for a single module.

   <p>The constituent modes of OUTPUT needed for the compilation of single
modules have been described in B2.1.  The remaining imperatives can
be divided into three groups

     <ol type=1 start=1>
<li>Giving information about the current compilation
          <dl>
<dt><code>XMODINFO</code><dd>gives the name and type of the current module
<br><dt><code>XSPEC</code><dd>gives information about a <code>HERE</code> clause, or the
current module if it is a <code>DECS</code> module
<br><dt><code>XTDTYPE</code><dd>contains the local number and type of a cc module
<br><dt><code>XBUTYPE</code><dd>gives advance notice of items to be kept from a <code>DECS</code> module
<br><dt><code>XCOMPTYPE</code><dd>describes the properties of a composition module
<br><dt><code>XKEEPS</code><dd>contains the decnos of items kept from a <code>DECS</code> module
</dl>

     <li>Giving information about other modules
          <dl>
<dt><code>XTDEC</code><dd>defines a kept identifier available to the current module
<br><dt><code>XTMODULE</code><dd>introduces an external module
<br><dt><code>XINTERF</code><dd>describes a keeplist and introduces a series of <code>XTDEC</code>s
</dl>

     <li>Representing constructions in the code
          <dl>
<dt><code>XOPENMODULE</code><dd>gives information about the code of a module and marks its beginning
<br><dt><code>XCLOSEMODULE</code><dd>marks the end of the code of a cc module
<br><dt><code>XCLOSURE</code><dd>deals with a composition module
<br><dt><code>XCALLMODULE</code><dd>starts a new cc-module running (produced by a <code>HERE</code> clause in the source-text)
</dl>
     </ol>

<h3 class="section"><a name="TOC110"></a>9.1 The Current Compilation</h3>

<p>The output to stream 0 is

<pre class="example">     XMODINFO   [XSPEC]*
</pre>
   <p class="noindent">followed by the <code>XEDIT</code> <code>down</code>, regardless of the type of the module. 
The mode definitions are as follows

<pre class="example">     MODE  XMODINFO  =  STRUCT (ID name, CAT l, g, INT type),
           XSPEC  =  STRUCT (ID f, INT no, nl, ng,
                             UNION (REF VECTOR [] CHAR,
                                    REF VECTOR [] CAT
                                   ) u
                            ),
</pre>
   <p class="noindent">where
<pre class="example">     MODE  CAT  =  STRUCT (ID n, f, INT level)
</pre>
   <p>The mode <code>CAT</code> (an abbreviation for `Compiled AT') is used to hold
context information and corresponds to <code>CONTEXT f IN n</code>
in some module.  The <code>name</code> field of <code>XMODINFO</code> contains the name of
the module and <code>type</code> is the number of <code>HERE</code> clauses or -1 for a
declarations module.  The contexts described by the other fields are
defined below.

   <p>If the module is being compiled at <code>CONTEXT VOID</code>, both <code>l</code>
and <code>g</code> will be null. 
Otherwise, suppose that the local context is <code>CONTEXT a IN b</code>
(where for a simple program <code>b</code> will be the standard prelude). 
Then the first two items in the <code>l</code> field will be <code>(b, a)</code>.  If <code>b</code> was
compiled at <code>CONTEXT VOID</code>, <code>g</code> will be null.  If not, <code>g</code>
describes the prelude context from which <code>b</code> was derived.

   <p>For a cc-module or composition module, there will be one <code>XSPEC</code>
corresponding to each <code>HERE</code> Clause.  The name of the <code>HERE</code> clause is
<code>f</code> and <code>no</code> is its number.  The remaining fields contain information
on the keeplist (normally given in brackets after <code>HERE</code> in the source
text) available to the module to be inserted.

   <p>If the module is a declarations module, the <code>XSPEC</code> contains its own
name and the <code>no</code> field is 0.

   <p>The fields <code>nl</code> and <code>ng</code> are the number of modules accessible at the
local and global levels respectively.  The mode of <code>u</code> depends on the
type of the module; for a cc-module or declarations module it refers
to a <code>VECTOR [] CHAR</code> containing a coded form of the keeplist.  The <code>u</code>
field of a composition module contains a <code>REF VECTOR [] CAT</code>, allowing
access to all of its context information.

   <p>The output to level 1 depends on the type of module

     <dl>
<dt>composition<dd><code>XCOMPTYPE</code>
<br><dt>cc<dd><code>XSIZES</code>, <code>REF VECTOR [] MDE</code>, <code>XTDTYPE</code>
<br><dt>declarations<dd><code>XSIZES</code>,  <code>REF VECTOR [] MDE</code>, <code>XBUTYPE</code>
</dl>

   <p>In each case an <code>XEDIT</code> <code>down</code> switches the reader to stream 2.  <code>XSIZES</code>
and <code>MDE</code> have been described in part B, except for the last two fields
of <code>XSIZES</code>.  The field <code>nomodules</code> contains the total number of modules
involved and <code>nolibinds</code> gives the size of the array required to hold
details of identifiers kept from other modules.

   <p>The modes <code>XCOMPTYPE</code>, <code>XTDTYPE</code> and <code>XBUTYPE</code> are given by

<pre class="example">     MODE  XCOMPTYPE  =  STRUCT (INT moduleno, type, maxmodule),
           XTDTYPE  =  STRUCT (INT moduleno, type),
           XBUTYPE  =  STRUCT (REF VECTOR [] INT decnos, modes)
</pre>
   <p>The type fields are the same as in <code>XMODINFO</code> (-1 for a declarations
module, otherwise the number of <code>HERE</code> clauses) and the <code>moduleno</code> is the
local number given to the module.  <code>maxmodule</code> is the maximum number of
modules directly involved in the composition.  The purpose of <code>XBUTYPE</code>
is to give advance notice of the identifiers and routine texts that
are to be kept.  The <code>decnos</code> array contains the declaration numbers and
the modes array, which is the same size, contains the modes of these
kept objects.  The <code>decnos</code> are repeated at the end of the compilation
of a declarations module, where they are output as an <code>XKEEPS</code>
(= <code>REF VECTOR [] INT</code>).

<h3 class="section"><a name="TOC111"></a>9.2 Parameters Of The Compile Procedure</h3>

<pre class="example">     PROC give module details = (ID name, INT mn, BOOL comp) YMODINFO:
     
     PROC give spec = (ID n, f, YM ym) YSPEC:
</pre>
   <p>The above procedures are the parameters of the compile procedure that
are concerned with modules, where

<pre class="example">     MODE  YMODINFO  =  STRUCT (XMODINFO xmi, YM ym),
           YSPEC  =  STRUCT (XSPEC xs, YS ys),
           YM  =  STRUCT (INT version, address),
           YS  =  INT
</pre>
   <p>The modes <code>YM</code> and <code>YS</code> are implementation dependent and may be extended;
the above definitions are chosen so that they may contain the minimum
amount of information.

   <p>The action of <code>givemoduledetails</code> depends on the value of the second
parameter.  If it is 0, the procedure must return a <code>YMODINFO</code>, whose
<code>xmi</code> field is identical to the <code>XMODINFO</code> output on some previous
compilation of the module <code>x</code>, or has illegal type (-2) if not found. 
If the second parameter is non-zero, the compiler is looking for a
library declarations module whose keeplist contains the name <code>x</code>, as
specified by the second parameter below:

     <dl>
<dt>1<dd>identifier
<br><dt>2<dd>compound symbol (operator)
<br><dt>3<dd>bold symbol (mode or operator)
</dl>

   <p>The third parameter is <code>TRUE</code> if the module currently being compiled is
a composition module, otherwise <code>FALSE</code>.  The <code>ym</code> field of <code>YMODINFO</code>
has a version field which must change whenever the module <code>x</code> changes
significantly.  It also contains information to allow the translator
efficient access to the library.  It may be output as part of an
<code>XTMODULE</code> (see next section) to check that the module concerned has not
changed significantly between compilation and loading; it could also
be output in an <code>XINTERF</code> as a help in its other possible role as a fast
look-up.

   <p>When the compiler calls <code>givespec(n, f, ym)</code>, the result must be a <code>
YSPEC</code> whose <code>xs</code> field (of mode <code>XSPEC</code>) has name <code>f</code> and was
output by a previous compilation of module <code>n</code>; <code>ym</code> is the <code>ym</code>
field of <code>givemoduledetails(N, 0, )</code>.  The <code>ys</code> field contains the
version number (as for <code>ym</code>) and must change if the <code>XSPEC</code> changes in
any way.  A module <code>x</code> changes significantly if its stream 0 is altered in any
way.

<h3 class="section"><a name="TOC112"></a>9.3 Information About Other Modules</h3>

<p>Stream 2 contains information defining the kept names, if any,
available to the current module as a result of its context.  This
will be given by

<pre class="example">     XINTERF   XTDEC   [XTDEC]*, where
     
     MODE  XINTERF  =  STRUCT (ID name, YM ym, ID formal, YS ys,
                               INT level, ownlevel
                              ),
           XTDEC  =  STRUCT (BOOL bu, INT level, REF IDDEC id),
           IDDEC  =  STRUCT (ID name, INT decno, level, mode, scope,
                             REF IDDEC rest
                            )
</pre>
   <p>Each keeplist contributing to the context will produce one <code>XINTERF</code>
(only in this position), immediately followed by a series of <code>XTDEC</code>s. 
Each <code>XTDEC</code> defines one identifier kept in this keeplist available
to the current module.  The fields <code>name</code> and <code>ym</code> identify the module
containing the keeplist, with the next two fields being provided so
that the translator may check that this is compatible with the
following <code>XTDEC</code>s, which were derived from a keeplist at compilation. 
The level field of <code>XINTERF</code> is the same as in the following <code>XTDEC</code>s;
this and <code>ownlevel</code> will be discussed more fully later.

   <p>The above applies only to modules connected by means of a <code>CONTEXT</code>
specification.  Names derived from declarations modules, that arise
from the <code>USE</code> construction or the default library, are introduced on
stream 2 by

<pre class="example">     XTMODULE   XTDEC   [XTDEC]*,
</pre>
   <p class="noindent">where

<pre class="example">     MODE  XTMODULE  =  STRUCT (INT type, moduleno, ID name, YM ym)
</pre>
   <p>The <code>XTMODULE</code> is a general construction introducing an external module
and giving it a local module number.  The <code>name</code> and <code>ym</code> fields are used
to locate and check the module, with the <code>type</code> being the same as that
of its <code>XMODINFO</code>.  In the present case, the <code>type</code> will be -1 since the
module is a declarations module; this is the only situation in which
it will be followed by <code>XTDEC</code>s as above.  The <code>bu</code> field will be <code>TRUE</code>
if the <code>XTDEC</code> is introduced by an <code>XTMODULE</code>, otherwise <code>FALSE</code>.

   <p>The <code>IDDEC</code> pointed to by the <code>id</code> field of an <code>XTDEC</code> has the
same form as that of an <code>XIDDEC</code> (See B3.2).  If the <code>XTDEC</code> describes
a declaration from a declarations module in the default library, the <code>
decno</code> of the <code>IDDEC</code> is in a series which starts at <code>startlib + 1</code>. 
Each <code>decno</code> is used only once in a compilation and refers to an entry in
the <code>libinds</code> array.  For <code>XTDEC</code>s arising from a <code>CONTEXT</code>
specification or the <code>USE</code> construction, the declaration numbers are
normally included in the series for the current module (ie identifiers start
at 4 and procedures at <code>startrd + 1</code>).  However, the treatment is
different for an <code>XTDEC</code> corresponding to a variable which refers to a
generating routine for a kept mode.  Firstly, the translator must arrange for
the variable to be dereferenced; secondly, <code>startkmp</code> is added to its
declaration number.  The values of <code>startlib</code>, <code>startrd</code> and <code>
startkmp</code> are implementation dependent (see Appendix 5).

   <p>The stream language corresponding to the code of the module starts on
stream 3.  There is an <code>XEDIT</code> <code>down</code> at the end of stream 2.

<h3 class="section"><a name="TOC113"></a>9.4 A Model For A Running CC Module</h3>

<p>The model given below describes the context information that is
available to a running cc module.  The simplest way to present it is
by means of Algol 68 mode declarations, even though they would not
appear in any translator.  The current module may be thought of as a
<code>CONINFO</code> current, where

<pre class="example">     MODE  CONINFO  =  STRUCT( REF CONINFO last, REF [] CLOSURE holes,
                               [] REF CONINFO condisp, [] VALUE keeps
                             ),
           CLOSURE  =  STRUCT (CODE code, REF [] CLOSURE holes)
</pre>
   <p>Suppose the current context is <code>CONTEXT p IN q</code>.  Then the <code>last</code>
field refers to the <code>CONINFO</code> of the module <code>q</code>, with <code>keeps</code>
providing information about the keeplist given at the <code>HERE</code> clause <code>
p</code>.  <code>holes</code> are the <code>HERE</code> clauses of this module, while the <code>
condisp</code> field contains the <code>CONINFO</code>s of all modules accessible to this one. 
There is in the <code>condisp</code> and <code>keeps</code> arrays because indexing should be possible
without requiring descriptors.

   <p>A <code>CONINFO</code> is rather similar to a procedure environment, with holes and
keeps being like parameters and <code>condisp</code> like a procedure display.  New
<code>CONINFO</code>s are added to this array dynamically by means of <code>XCALLMODULE</code>
(see next section, while <code>CLOSURE</code>s may be constructed at load-time by
means of <code>XCLOSURE</code>s.

   <p>The <code>level</code> fields of the modes in the previous section can be defined
most easily in terms of this model.  The <code>level</code> field of <code>XINTERF</code> is the
index into <code>condisp OF current</code> that gives the <code>CONINFO</code> of the relevant
module. This <code>CONINFO</code> contains the <code>VALUE</code>s which are the kepts defined
by the <code>XTDEC</code>s following the <code>XINTERF</code>; the level of the <code>XINTERF</code> is
repeated in the succeeding <code>XTDEC</code>S.  The <code>ownlevel</code> field of an <code>XINTERF</code>
is the size of the <code>condisp</code> of the <code>CONINFO</code> of this module.

   <p>There is a level associated with each <code>XTMODULE</code>, but this is given only
in the succeeding <code>XTDEC</code>s and is not part of the mode <code>XTMODULE</code>.  The
level fields of the <code>XTDEC</code>s define the context under which the module
was compiled as being 0 for <code>CONTEXT VOID</code> or equal to the level of some
previously introduced <code>XINTERF</code>.

<h3 class="section"><a name="TOC114"></a>9.5 Constructions In The Code</h3>

<p>The code of a cc-module is introduced by an <code>XOPENMODULE</code> and terminated
by an <code>XCLOSEMODULE</code>, where

<pre class="example">     MODE  XOPENMODULE  =  STRUCT (ID name,
                                   INT maxlevel, nof, moduleno
                                  ),
           XCLOSEMODULE  =  STRUCT (INT moduleno, nof)
</pre>
   <p>The <code>name</code> field of <code>XOPENMODULE</code> gives the name of the module, with
the fields common to both modes, <code>nof</code> and <code>moduleno</code>, giving the number
of formals and local module number respectively.  The <code>maxlevel</code>
field is similar to the <code>ownlevel</code> of an <code>XINTERF</code>, containing
<code>UPB condisp OF current</code>; this could be used to combine the <code>condisp</code>
with the normal procedure display by allowing space for a copy of
the <code>condisp</code> at its base.  A composition module may include several
open-close pairs around each synthetically generated module, whereas
a normal cc-module has only one pair round its code.

   <p>The mode <code>XCLOSURE</code>, defined by

<pre class="example">     MODE  XCLOSURE  =  STRUCT (INT body, REF VECTOR [] INT actuals,
                                INT moduleno
                               ),
</pre>
   <p class="noindent">is used to make up a new <code>CLOSURE newcl</code>, with the <code>moduleno</code> field
giving it a local module number.  The other fields contain local
module numbers that have been previously introduced by <code>XTMODULE</code>s,
<code>XOPENMODULE</code>s or other <code>XCLOSURE</code>s.  The <code>body</code> field refers to the
module containing the instructions that become <code>code OF newcl</code>.  The
elements of <code>actuals</code> refer to the modules that are supplied to the
<code>HERE</code> clauses; these are set up as the <code>holes OF newcl</code>.

   <p>The code produced by a <code>HERE</code> clause will be an <code>XCALLMODULE</code>, where

<pre class="example">     MODE  XCALLMODULE  =  STRUCT (INTPAIR body,
                                   REF VECTOR [] INTRIPLE kset,
                                   REF VECTOR [] INT keeps, INT last
                                  ),
           INTPAIR  =  STRUCT (INT i, j),
           INTRIPLE  =  STRUCT (INT i, j, k)
</pre>
   <p>Its purpose is to start running a new cc-module, having set up a new
<code>CONINFO newcon</code>, created as shown below.  It will be helpful to first
define a recursive procedure:

<pre class="example">     PROC l = (INT n) CONINFO:
     IF  n = 0
     THEN  current
     ELSE  last OF l(n - 1)
     FI
</pre>
   <p>The <code>Body</code> field is used to construct the <code>CLOSURE</code> for the module to be
run, given by

<pre class="example">     CLOSURE m = (holes OF l(j OF body OF c))[i OF body OF c],
</pre>
   <p class="noindent">where <code>c</code> is the <code>XCALLMODULE</code> concerned.  The fields of the <code>CONINFO
newcon</code> are set up as follows:

     <dl>
<dt><code>holes OF newcon</code><dd><code>:= holes OF m</code>
<br><dt><code>last OF newcon</code><dd><code> := l(last OF c)</code>
<br><dt><code>keeps OF newcon</code><dd>consists of the values corresponding to <code>decno</code>s given in <code>keeps OF c</code>
<br><dt><code>condisp OF newcon</code><dd>is constructed by the concatenation in order of
<code>(condisp OF l(k))[i:j]</code> for each of the triples <code>I</code>, <code>J</code>,
<code>k</code> in <code>kset OF c</code>, with <code>newcon</code> added as its final element
</dl>

<h3 class="section"><a name="TOC115"></a>9.6 An Example Of Modular Compilation</h3>

<p>The basis of this example is the use of two environmental packages, as
in C2.7.  There are altogether 10 modules, a brief description of
which is given below.

     <dl>
<dt><code>package1</code><dd>cc, contains 2 <code>HERE</code> clauses for user programs
<br><dt><code>package2</code><dd>cc, contains <code>HERE</code> clause for user program
<br><dt><code>comp2</code><dd>composition, contains 2 <code>HERE</code> clauses, one of which allows the
user program to use both packages, as in C2.7. 
<br><dt><code>cc1</code><dd>cc, the module to be inserted into the first hole in the above context. 
It also contains a <code>HERE</code> clause and uses two <code>DECS</code> modules. 
<br><dt><code>decs3</code><dd>declarations, uses no other modules
<br><dt><code>decs4</code><dd>declarations, uses <code>decs3</code> and <code>package1</code>
<br><dt><code>cc3</code><dd>cc, the module to fill the hole in <code>cc1</code>
<br><dt><code>comp1</code><dd>composition, composes <code>cc1</code> to incorporate <code>cc3</code>
<br><dt><code>cc2</code><dd>cc, the module to be inserted into the second hole in <code>comp2</code>
<br><dt><code>starter</code><dd>composition, runs the complete program

   </dl>

   <p>The source texts take the following forms:

<pre class="example">     (1)  PROGRAM (userprog, results) package1
          BEGIN ....
                ....
                HERE userprog(keeplist1)
                ....
                HERE results(keeplistr)
                ....
          END
          FINISH
     
     (2)  PROGRAM (userprog) package2
          BEGIN ....
                ....
                HERE userprog(keeplist2)
                ....
          END
          FINISH
     
     (3)  PROGRAM (user1, user2) comp2
          COMPOSE package1(userprog = package2(userprog = HERE user1),
                           results = HERE user2)
          FINISH
     
     (4)  PROGRAM (hole) cc1
          CONTEXT user1 IN comp2
          USE decs3, decs4
          BEGIN ....
                ....
                HERE hole(keeplist)
                ....
          END
          FINISH
     
     (5)  DECS decs3:
          ....
          ....
          KEEP keeplist3
          FINISH
     
     (6)  DECS decs4
          CONTEXT userprog IN package1
          USE decs3:
          ....
          ....
          KEEP keeplist4
          FINISH
     
     (7)  PROGRAM cc3
          CONTEXT hole IN cc1
          USE decs3
          BEGIN ....
                ....
          END
          FINISH
     
     (8)  PROGRAM comp1
          COMPOSE cc1(hole = cc3)
          FINISH
     
     (9)  PROGRAM cc2
          CONTEXT user2 IN comp2
          BEGIN ....
                ....
          END
          FINISH
     
     (10) PROGRAM starter
          COMPOSE comp2(user1 = comp1, user2 = cc2)
          FINISH
</pre>
   <h4 class="subsection"><a name="TOC116"></a>9.6.1 Stream Language Produced For The Above Modules</h4>

<p>The outputs are given in the order in which they would be read by the
translator.  <code>XTDEC*</code> indicates an arbitrary number of <code>XTDEC</code>s.  The
values of the fields (except for version fields) are shown on the right-hand
side.  The <code>u</code> field of <code>XSPEC</code> has mode <code>REF VECTOR [] CHAR</code> if
it refers to a keeplist - otherwise it has mode <code>REF VECTOR [] CAT</code>.

   <p>The following declarations are used:

<pre class="example">     CAT c = (%stdprelude, %program, 1)     {default context}
     CAT n = ("", "", 0)                    {VOID context}
     CAT u1 = (package1, userprog, 1)
     CAT ur = (package1, results, 1)
     CAT u2 = (package2, userprog, 1)
     ID item = description of a kept identifier
     ID lastid = description of the last declared identifier
</pre>
   <p>modes: the <code>REF VECTOR [] MDE</code> imperative

<pre class="example">     (1)  PACKAGE1
     
     XMODINFO       name = package1, l = c, g = n, type = 2
     XSPEC          f = userprog, no = 1, nl = 1, ng = 1, u -&gt; keeplist1
     XSPEC          f = results, no = 2, nl = 1, ng = 1, u -&gt; keeplistr
     XSIZES
     modes
     XTDTYPE        moduleno = 1, type = 2
     XINTERF        name = %stdprelude, formal = %program, level = 1,
                    ownlevel = 1
     XTDEC*         bu = FALSE, level = 1, id = item
     XOPENMODULE    name = package1, maxlevel = 1, nof = 2, moduleno = 1
     XCALLMODULE    body = (1,0), kset = (1,1,0), keeps = keeplist1,
                    last = 0
     XCALLMODULE    body = (2,0), kset = (1,1,0), keeps = keeplistr,
                    last = 0
     XCLOSEMODULE   moduleno = 1, nof = 2
     
     
     (2)  PACKAGE2
     
     XMODINFO       name = package2, l = c, g = n, type = 1
     XSPEC          f = userprog, no = 1, nl = 1, ng = 1, u -&gt; keeplist2
     XSIZES
     modes
     XTDTYPE        moduleno = 1, type = 1
     XINTERF        name = %stdprelude, formal = %program, level = 1,
                    ownlevel = 1
     XTDEC*         bu = FALSE, level = 1, id = item
     XOPENMODULE    name = package2, maxlevel = 1, nof = 1, moduleno = 1
     XCALLMODULE    body = (1,0), kset = (1,1,0), keeps = keeplist2,
                    last = 0
     XCLOSEMODULE   moduleno = 1, nof = 1
     
     
     (3)  COMP2
     
     XMODINFO       name = comp2, l = c, g = n, type = 2
     XSPEC          f = user1, no = 1, nl = 2, ng = 1, u -&gt; (u1,u2)
     XSPEC          f = user2, no = 2, nl = 1, ng = 1, u -&gt; ur
     XCOMPTYPE      moduleno = 6, type = 2, maxmodule = 6
     XTMODULE       type = 2, moduleno = 1, name = package1
     XTMODULE       type = 1, moduleno = 2, name = package2
     XOPENMODULE    name = user1, maxlevel = 2, nof = 0, moduleno = 3
     XCALLMODULE    body = (1,2), kset = ((1,2,2), (0,2,2)), keeps = NIL,
                    last = 2
     XCLOSEMODULE   moduleno = 3, nof = 0
     XCLOSURE       body = 2, actuals = (3), moduleno = 4
     XOPENMODULE    name = user2, maxlevel = 2, nof = 0, moduleno = 5
     XCALLMODULE    body = (2,1), kset = (0,1,2), keeps = NIL, last = 1
     XCLOSEMODULE   moduleno = 5, nof = 0
     XCLOSURE       body = 1, actuals = (4,5), moduleno = 6
     
     
     (4)  CC1
     
     XMODINFO       name = cc1, l = (comp2, user1, 3), g = c, type = 1
     XSPEC          f = hole, no = 1, nl = 1, ng = 1, u -&gt; keeplist
     XSIZES
     modes
     XTDTYPE        moduleno = 3, type = 1
     XINTERF        name = %stdprelude, formal = %program, level = 1,
                    ownlevel = 1
     XTDEC*         bu = FALSE, level = 1, id = item
     XINTERF        name = package1, formal = userprog, level = 2,
                    ownlevel = 2
     XTDEC*         bu = FALSE, level = 2, id = item
     XINTERF        name = package2, formal = userprog, level = 3,
                    ownlevel = 2
     XTDEC*         bu = FALSE, level = 3, id = item
     XINTERF        name = comp2, formal = user1, level = 4, ownlevel = 3
     XTDEC*         bu = FALSE, level = 4, id = lastid
     XTMODULE       type = -1, moduleno = 1, name = decs3
     XTDEC*         bu = TRUE, level = 3, id = item
     XTMODULE       type = -1, moduleno = 2, name = decs4
     XTDEC*         bu = TRUE, level = 3, id = item
     XOPENMODULE    name = cc1, maxlevel = 4, nof = 1, moduleno = 3
     XCALLMODULE    body = (1,0), kset = (1,1,0), keeps = keeplist,
                    last = 0
     XCLOSEMODULE   moduleno = 3, nof = 1
     
     
     (5)  DECS3
     
     XMODINFO       name = decs3, l = c, g = n, type = -1
     XSPEC          f = decs3, no = 0, nl = 1, ng = 0, u -&gt; keeplist3
     XSIZES
     modes
     XBUTYPE        keeplist3
     XINTERF        name = %stdprelude, formal = %program, level = 1,
                    ownlevel = 1
     XTDEC*         bu = FALSE, level = 1, id = item
     XKEEPS         keeplist3
     
     
     (6)  DECS4
     
     XMODINFO       name = decs4, l = u1, g = c, type = -1
     XSPEC          f = decs4, no = 0, nl = 1, ng = 1, u -&gt; keeplist4
     XSIZES
     modes
     XBUTYPE        keeplist4
     XINTERF        name = %stdprelude, formal = %program, level = 1,
                    ownlevel = 1
     XTDEC*         bu = FALSE, level = 1, id = item
     XINTERF        name = package1, formal = userprog, level = 2,
                    ownlevel = 2
     XTDEC*         bu = FALSE, level = 2, id = item
     XTMODULE       type = -1, moduleno = 1, name = decs3
     XTDEC*               bu = TRUE, level = 3, id = item
     XKEEPS         keeplist4
     
     
     (7)  CC3
     
     XMODINFO       name = cc3, l = (cc1, hole, 1), g = c, type = 0
     XSIZES
     modes
     XTDTYPE        moduleno = 2, type = 0
     XINTERF        name = %stdprelude, formal = %program, level = 1,
                    ownlevel = 1
     XTDEC*         bu = FALSE, level = 1, id = item
     XINTERF        name = cc1, formal = hole, level = 2, ownlevel = 2
     XTDEC*         bu = FALSE, level = 2, id = item
     XTMODULE       type = -1, moduleno = 1, name = decs3
     XTDEC*         bu = TRUE, level = 3, id = item
     XOPENMODULE    name = cc3, maxlevel = 2, nof = 0, moduleno = 2
     XCLOSEMODULE   moduleno = 2, nof = 0
     
     
     (8)  COMP1
     
     XMODINFO       name = comp1, l = (comp2, user1, 3), g = c, type = 0
     XCOMPTYPE      moduleno = 3, type = 0, maxmodule = 3
     XTMODULE       type = 1, moduleno = 1, name = cc1
     XTMODULE       type = 0, moduleno = 2, name = cc3
     XCLOSURE       body = 1, actuals = (2), moduleno = 3
     
     
     (9)  CC2
     
     XMODINFO       name = cc2, l = (comp2, user2, 2), g = c, type = 0
     XSIZES
     modes
     XTDTYPE        moduleno = 1, type = 0
     XINTERF        name = %stdprelude, formal = %program, level = 1,
                    ownlevel = 1
     XTDEC*         bu = FALSE, level = 1, id = item
     XINTERF        name = package1, formal = userprog, level = 2,
                    ownlevel = 2
     XTDEC*         bu = FALSE, level = 2, id = item
     XINTERF        name = comp2, formal = user2, level = 3, ownlevel = 2
     XTDEC*         bu = FALSE, level = 3, id = lastid
     XOPENMODULE    name = cc2, maxlevel = 3, nof = 0, moduleno = 1
     XCLOSEMODULE   moduleno = 1, nof = 0
     
     
     (10) STARTER
     
     XMODINFO       name = starter, l = c, g = n, type = 0
     XCOMPTYPE      moduleno = 4, type = 0, maxmodule = 4
     XTMODULE       type = 2, moduleno = 1, name = comp2
     XTMODULE       type = 0, moduleno = 2, name = comp1
     XTMODULE       type = 0, moduleno = 3, name = cc2
     XCLOSURE       body = 1, actuals = (2,3), moduleno = 4
</pre>
   <h2 class="appendix"><a name="TOC117"></a>Aldono A Values and representations of symbols</h2>

<p><strong>Note:</strong> symbols marked with a * must have a single-character
      representation provided for them.

   <p>The values of the symbols are given in brackets.

<h3 class="section"><a name="TOC118"></a>A.1 Note</h3>

<p>Any representation whose meaning is undefined must be given one of
the following values in the <code>charset</code> array or <code>lookup</code>
procedure:

     <dl>
<dt>156 (other bold)<dd>if the representation is to be an acceptable form for a user-defined
mode name or operator

     <br><dt>176 (other op)<dd>if the representation is to be acceptable as a user-defined operator
symbol but unacceptable as a mode name

     <br><dt>100 (illegal)<dd>if the representation is to be illegal
</dl>

<h2 class="appendix"><a name="TOC119"></a>Aldono B Fixed Mode Numbers</h2>

<p>The mode numbers given below are fixed for all programs. 
For 1 to 21, 29 and 30, the mode <code>MDE</code> decomposes to <code>PRIMITIVE</code>.

   <p>These mode numbers assume that there may be up to 1 <code>SHORT</code> or 2 <code>
LONG</code> symbols before a mode or denotation (although these are not all required
to represent different lengths).  It is possible to allow <code>SHORT SHORT</code>
(at the expense of <code>LONG LONG</code>) by interchanging <code>LONG</code> and
<code>SHORT</code> in the following table.  If this is done, the values for
the symbols
<code>LONG</code> and <code>SHORT</code>, <code>LENG</code> and <code>SHORTEN</code> must also be
interchanged.

     <dl>
<dt>1<dd><code>vacmode</code>
<br><dt>2<dd><code>skipmode</code>
<br><dt>3<dd><code>nilmode</code>
<br><dt>4<dd><code>gotomode</code>
<br><dt>5<dd><code>voidmode</code>
<br><dt>6<dd><code>faultmode</code> (does not occur in stream language)

     <br><dt>7<dd><code>BOOL</code>
<br><dt>8<dd><code>CHAR</code>
<br><dt>9<dd><code>FORMAT</code>

     <br><dt>10<dd><code>SHORT BITS</code>
<br><dt>11<dd><code>BITS</code>
<br><dt>12<dd><code>LONG BITS</code>
<br><dt>13<dd><code>LONG LONG BITS</code>
<br><dt>14<dd><code>SHORT INT</code>
<br><dt>15<dd><code>INT</code>
<br><dt>16<dd><code>LONG INT</code>
<br><dt>17<dd><code>LONG LONG INT</code>
<br><dt>18<dd><code>SHORT REAL</code>
<br><dt>19<dd><code>REAL</code>
<br><dt>20<dd><code>LONG REAL</code>
<br><dt>21<dd><code>LONG LONG REAL</code>

     <br><dt>22<dd><code>SHORT COMPL  =  STRUCT (SHORT REAL re, im)</code>
<br><dt>23<dd><code>COMPL  =  STRUCT (REAL re, im)</code>
<br><dt>24<dd><code>LONG COMPL  =  STRUCT (LONG REAL re, im)</code>
<br><dt>25<dd><code>LONG LONG COMPL  =  STRUCT (LONG LONG REAL re, im)</code>

     <br><dt>26<dd><code>VECTOR [] CHAR</code>
<br><dt>27<dd><code>[] CHAR</code>
<br><dt>28<dd><code>collatmode</code>

     <br><dt>29<dd><code>XTYPE</code>
<br><dt>30<dd><code>YTYPE</code>
</dl>

<h2 class="appendix"><a name="TOC120"></a>Aldono C Numbering of standard prelude operators in <code>XOPER</code></h2>

<p>Key to headings:

     <dl>
<dt><code>BL</code><dd><code>BOOL</code>
<br><dt><code>C</code><dd><code>CHAR</code>
<br><dt><code>LB</code><dd><code>BITS</code> (possibly with <code>LONG</code> or <code>SHORT</code> prefixes)
<br><dt><code>I</code><dd><code>INT</code>

     <br><dt><code>LI</code><dd><code>INT</code> (possibly with <code>LONG</code> or <code>SHORT</code> prefixes)
<br><dt><code>LR</code><dd><code>REAL</code> (possibly with <code>LONG</code> or <code>SHORT</code> prefixes)
<br><dt><code>LC</code><dd><code>COMPL</code> (possibly with <code>LONG</code> or <code>SHORT</code> prefixes)
<br><dt><code>VC</code><dd><code>VECTOR [] CHAR</code> (<code>REF FLEX</code> for <code>+:=, *:=)</code>

     <br><dt><code>AC</code><dd><code>] CHAR</code> (<code>REF FLEX</code> for <code>+:=, *:=)</code>
<br><dt><code>V</code><dd> Any vector
<br><dt><code>A</code><dd>Any array
S
Any straight
</dl>

<h3 class="appendixsec"><a name="TOC121"></a>C.1 Monadic operators</h3>

<pre class="example">                     BL C  LB I    LI LR LC VC   AC V  A  S
               op                  version number
           number
     +         0     -  -  -  -    1  2  3  -    -  -  -  -
     -         1     -  -  -  -    1  2  3  -    -  -  -  -
     UPB       2     -  -  -  -    -  -  -  -    -  1  2  3
     LWB       3     -  -  -  -    -  -  -  -    -  1  2  3
     NOT       4     1  -  2  -    -  -  -  -    -  -  -  -
     
     ABS       5     1  2  3  -    4  5  6  -    -  -  -  -
     BIN       6     -  -  -  -    1  -  -  -    -  -  -  -
     REPR      7     -  -  -  1    -  -  -  -    -  -  -  -
     LENG      8     -  -  1  -    2  3  4  -    -  -  -  -
     SHORTEN   9     -  -  1  -    2  3  4  -    -  -  -  -
     
     ODD      10     -  -  -  -    1  -  -  -    -  -  -  -
     SIGN     11     -  -  -  -    1  2  -  -    -  -  -  -
     ROUND    12     -  -  -  -    -  1  -  -    -  -  -  -
     ENTIER   13     -  -  -  -    -  1  -  -    -  -  -  -
     RE       14     -  -  -  -    -  -  1  -    -  -  -  -
     
     IM       15     -  -  -  -    -  -  1  -    -  -  -  -
     ARG      16     -  -  -  -    -  -  1  -    -  -  -  -
     CONJ     17     -  -  -  -    -  -  1  -    -  -  -  -
</pre>
<h3 class="appendixsec"><a name="TOC122"></a>C.2 Dyadic operators</h3>

<pre class="example">                     BL C  LB I    LI LR LC VC   AC V  A  S
              op                   version number
            number
     +         0     -  1  -  -    2  3  4  5    6  -  -  -
     -         1     -  -  -  -    1  2  3  -    -  -  -  -
     UPB       2     -  -  -  -    -  -  -  -    -  -  1  -
     LWB       3     -  -  -  -    -  -  -  -    -  -  1  -
     ANDTH     4     1  -  -  -    -  -  -  -    -  -  -  -
     
     OREL      5     1  -  -  -    -  -  -  -    -  -  -  -
     &lt;         6     -  1  -  -    2  3  -  4    5  -  -  -
     &gt;         7     -  1  -  -    2  3  -  4    5  -  -  -
     &lt;=        8     -  1  2  -    3  4  -  5    6  -  -  -
     &gt;=        9     -  1  2  -    3  4  -  5    6  -  -  -
     
     =        10     1  2  3  -    4  5  6  7    8  -  -  -
     /=       11     1  2  3  -    4  5  6  7    8  -  -  -
     *        12     -  1  -  -    2  3  4  5    6  -  -  -
     /        13     -  -  -  -    1  2  3  -    -  -  -  -
     OVER     14     -  -  -  -    1  -  -  -    -  -  -  -
     
     MOD      15     -  -  -  -    1  -  -  -    -  -  -  -
     **       16     -  -  -  -    1  2  3  -    -  -  -  -
     I        17     -  -  -  -    1  2  -  -    -  -  -  -
     SHL      18     -  -  1  -    -  -  -  -    -  -  -  -
     SHR      19     -  -  1  -    -  -  -  -    -  -  -  -
     
     ELEM     20     -  -  1  -    -  -  -  -    -  -  -  -
     PLUSAB   21     -  -  -  -    1  2  3  4    5  -  -  -
     MINUSAB  22     -  -  -  -    1  2  3  -    -  -  -  -
     TIMESAB  23     -  -  -  -    1  2  3  4    5  -  -  -
     OVERAB   24     -  -  -  -    1  -  -  -    -  -  -  -
     
     MODAB    25     -  -  -  -    1  -  -  -    -  -  -  -
     DIVAB    26     -  -  -  -    -  1  2  -    -  -  -  -
     IS       27       (only version number = 1)
     ISNT     28       (only version number = 1)
     AND      29     1  -  2  -    -  -  -  -    -  -  -  -
     
     OR       30     1  -  2  -    -  -  -  -    -  -  -  -
     PLUSTO   31     -  -  -  -    -  -  -  1    2  -  -  -
     CYCLE    32     -  -  -  -    -  -  -  -    -  -  1  -
</pre>
<h2 class="appendix"><a name="TOC123"></a>Aldono D Extensions To ALGOL 68</h2>

<h3 class="appendixsec"><a name="TOC124"></a>D.1 Vectors and indexable structures</h3>

<p>A vector is a one-dimensional array with an understood lower bound of
1.  A typical declaration would be

<pre class="example">     VECTOR [n] INT v;
</pre>
   <p class="noindent">where the size <code>n</code> can be any unitary clause.  A vector can be flexible
or not, and subscripted and trimmed like an array, though the use of
<code>AT</code> results in an array.  In strong contexts, a single object can
be <dfn>rowed</dfn> to a vector.  The overheads associated with vectors are
smaller than arrays, and assignment of vectors is simpler than for
arrays because the elements are always contiguous.

   <p>The indexable structure or more briefly <dfn>i-struct</dfn> represents the
ultimate step in removing array overheads while preserving the
facility of indexing.  It groups together a fixed number of objects of
any specified mode; for example, a <code>STRUCT 30 REAL</code> consists of 30 reals
and the size 30 is part of the mode.  The size must therefore be an
integer denotation; the permissible range of values is from 1 to
<code>maxistruct</code> (see Appendix 5).  An i-struct can be indexed with the
same notation as for an array, and the indexing starts at 1.  If
trimmed, it normally gives rise to a vector (although the <code>AT</code>
construction produces an array).  In strong contexts, a single object
can be <dfn>rowed</dfn> to an i-struct.  The i-struct enables fixed length rows
of characters to be handled with the efficiency expected for Algol 68
<code>BYTES</code>, <code>LONG BYTES</code> etc, but without any restrictions on length.

   <p>Coercions on i-structs and vectors are all in the direction i-struct
to vector to array.  All such coercions (including ref i-struct to ref
vector etc) are allowed before uniting.  However, i-structs, vectors
and arrays of the same mode can exist side by side in the same union,
and any seeming ambiguity when uniting is avoided by preference for
minimum travel in the &ldquo;i-struct to vector to array&rdquo; direction.  The
same preference rule applies to operator selection, as shown in the
following example:

<pre class="example">     OP  Y2  =  (VECTOR [] REAL p) ... ... ;
     OP  Y2  =  ([] REAL p) ... ... ;
</pre>
   <p>With these two declarations in force, an operand of mode <code>STRUCT 4 REAL</code>
would be coerced to <code>VECTOR [] REAL</code> and the first operator definition
would be selected.

   <p>String denotations are i-structs (eg <code>"ABC"</code> is <code>STRUCT 3 CHAR</code>), but the
above coercions ensure that users wishing to avoid the language
extensions need not be aware of them.  The word <code>VECTOR</code> does not appear
in compile-time diagnostic messages unless it has already been
explicitly used in the source-text, while strings like <code>"ABC"</code> are
typically described as <code>3 CHAR</code> rather than <code>STRUCT 3 CHAR</code>.  The
mode of the empty string <code>""</code> is <code>STRUCT 0 CHAR</code>, even though i-structs
with zero size cannot be declared.

<h3 class="appendixsec"><a name="TOC125"></a>D.2 The <code>FORALL</code> statement</h3>

<p>The <code>FORALL</code> statement has been introduced for efficiency in sequencing
through all the elements in one dimension of an array, or all the
elements of a vector.  As an example, in the unitary clause

<pre class="example">     FORALL  xi IN x  DO  xi *:= xi  OD
</pre>
   <p>the new identifier <code>xi</code> (declared by <code>FORALL</code>) successively takes each of
the values <code>x[i]</code> with <code>i</code> going <code>FROM LWB x TO UPB x</code>.  The effect of this
example, therefore, is to square all the elements of <code>x</code>.  It avoids
explicit indexing and the associated overheads in the compiled code. 
There can be a sequence of parts like <code>xi IN x</code> provided each has the
same bounds.  For example,

<pre class="example">     VECTOR [10] INT v;
     [10, n : m] REAL w;
     FORALL  elemv IN v,  elemw IN w
     DO  f(elemv, elemw)  OD
</pre>
   <p class="noindent">applies the function <code>f</code> to all pairs of arguments <code>(v[i], w[i, ])</code>
for <code>i</code> <code>FROM 1 TO 10</code>.

   <p>A <code>FORALL</code> statement can have a while part, and the range of the
identifiers declared by <code> FORALL</code> (eg <code>elemv</code>, <code>elemw</code>) is the <code>WHILE</code> clause
and the <code>DO</code> clause.

   <p>Primarily for use in conjunction with the <code>FORALL</code> statement, a new
dyadic operator, <code>CYCLE</code>, is defined to act on (ref) multi-dimensional
arrays.  The expression <code>n CYCLE w</code> delivers the (ref) array <code>w</code> with
a new descriptor, in which the dimensions are cycled to bring the
<code>(n+1)</code>th to the front.

<h3 class="appendixsec"><a name="TOC126"></a>D.3 Straightening</h3>

<p>A `straightening' facility is provided to enable Algol 68 programmers
to write transput procedures with arbitrarily structured parameters. 
Straightening is the reduction of any type of data structure to a
simple sequence - which we shall describe as a <dfn>straight</dfn>.  The basic
step is the coercion of a simple row or structure to a straight;
applied recursively, the method can be used to straighten data
structures of arbitrary complexity.

   <p>The mode <code>STRAIGHT U</code>, where <code>U</code> is any Algol 68 mode (but most commonly a
union), describes a set of objects of mode <code>U</code>.  In this respect it is
similar to <code>[] U</code>, but in other respects it is quite different and must
be treated as a new type of mode.  An actual straight is brought into
existence by strong coercion of a row, vector, structure, i-struct or
union.  Such modes are strongly coercible to <code>STRAIGHT U</code> if their
"members' can be coerced to <code>U</code> by uniting, straightening or any of the
coercions i-struct to vector to array (A4.1).  The coercions excluded
are dereferencing, deproceduring, widening and rowing.

   <p>Example 1

<pre class="example">     STRAIGHT UNION (INT, CHAR) s1 = "ABCD"
</pre>
   <p>As <code>CHAR</code> is coercible to <code>UNION(INT, CHAR)</code>, the i-struct <code>"ABCD"</code> can be
coerced to the <code>STRAIGHT</code>.  If <code>s1</code> were the formal parameter of an output
procedure, acceptable actuals would be a row of characters, row of
integers, structure with integer and character fields or a union of
integer and character.  However, a single <code>INT</code> or a single <code>CHAR</code> would
not be accepted.

   <p>Example 2

<pre class="example">     STRUCT (INT i, REAL r) p;
     STRAIGHT UNION (REF REAL, REF INT, REF CHAR) s2 = p
</pre>
   <p>The members of <code>p</code> have modes <code>REF INT</code> and <code>REF REAL</code>, both of which are
coercible to the given union, so <code>p</code> will be coercible to the mode of
<code>s2</code>.  Clearly, <code>s2</code> might be the formal parameter of an input procedure
and <code>p</code> its actual parameter.  The actual could not be a simple real,
integer or character variable.

   <p>Example 3

<pre class="example">     [3] INT v := (1, 2, 3);
     STRAIGHT INT s = v;
</pre>
   <p>In this example, the members of the variable <code>v</code> have mode <code>REF INT</code>,
but <code>s</code> is a straight of plain integers.  As it stands, <code>v</code> cannot be
straightened to <code>s</code> because dereferencing of members is not allowed. 
But as <code>v</code> can be dereferenced before straightening, the example is
correct.  Considered as a formal parameter for an output procedure, <code>s</code>
would handle any row or structure of integers, but not a single
integer by itself.

   <p>As a straight cannot represent an unstructured value, most
applications will demand that it be combined with basic modes in a
union, eg

<pre class="example">     UNION (INT, REAL, ... , STRAIGHT UNION (INT, REAL, ... ))
</pre>
   <p>This mode will handle an object of data which possesses structure at
no level (eg an <code>INT</code>) or one level (eg <code>[] REAL</code>, <code>STRUCT 17 INT</code>) but not
more.  When an object is being united to the above mode, then &mdash;
regardless of the order in which the constituent modes have been
written &mdash; the fit will be sought from the non-<code>STRAIGHT</code> modes first,
so as to avoid any possible ambiguities of coercion.

   <p>To handle one object structured at any number of levels, a recursive
mode is needed.

<pre class="example">     MODE  PRINTMODE  =  UNION (INT, REAL, ... , STRAIGHT PRINTMODE)
</pre>
   <p>The definition of <code>STRAIGHT</code> is such as permits this recursion. 
<code>PRINTMODE</code> will handle an integer, real, etc, or any row or structure
built up from all these to any depth.  For a corresponding input
parameter mode, the basic modes would each be preceded by a <code>REF</code>.

   <p>The parameter of the standard <code>print</code> procedure has mode <code>VECTOR [] PRINTMODE</code>
rather than <code>PRINTMODE</code>.  This allows the use of a collateral as the
actual parameter.

   <p>A straight cannot be handled with the full generality applicable to
other Algol 68 modes.  The manipulations are confined to subscripting
and interrogation by the operator <code>UPB</code>.  Let <code>m</code> stand for any mode, and
let <code>s</code> have mode <code>STRAIGHT M</code>.  Then <code>UPB s</code> gives the number of objects in
the straight, and <code>s[i]</code> picks out the <code>i</code>th object (<code>i</code> &gt;= 1).  There is no
such thing as a <code>STRAIGHT</code> generator or variable because objects of mode
<code>REF STRAIGHT</code> do not exist.

<h3 class="appendixsec"><a name="TOC127"></a>D.4 Low level facilities</h3>

<p>Code can be inserted in an Algol 68 program by the construction

<pre class="example">     mode CODE (unc, unc, ...) " code "
</pre>
   <p class="noindent">which is treated as a primary of the specified mode (absence of which
implies mode <code>VOID</code>).  The unitary clauses, to which no coercions are
applied, supply Algol 68 objects for use in the code.  Other alien
insertions, such as non-Algol procedures, must take the form

<pre class="example">     mode identifier = ALIEN " insertion "
</pre>
   <p><code>ALIEN</code> is allowed only in this identity declaration context.

   <p>An alternative method of expressing a string denotation is provided. 
This uses the <code>ABS</code> values of the characters rather than the
characters themselves, which might be non-printing characters.  The
<code>ABS</code> values can be to radix 2, 4, 8, 10 or 16, and must be
separated by spaces; the string must be preceded by <code>10r</code> or
<code>16r</code> or whatever the case may be.  Thus the following
3-character strings (or more strictly <code>STRUCT 3 CHAR</code>S) are
equivalent: <code>8r "1 15 251"</code>, <code>16r "1 d a9"</code>, where
<code>a</code>-<code>f</code> represent the digits 10-15.

<h3 class="appendixsec"><a name="TOC128"></a>D.5 Built-in operators</h3>

<p>The declaration

<pre class="example">     OP (INT, INT) INT  ** = BIOP 1013
</pre>
   <p class="noindent">declares the operator <code>**</code> in the usual way, but the definition is built
into the translator.  The integer after <code>BIOP</code> corresponds to the param
field of a <code>dyop</code> or <code>monop</code> (in <code>XOPER</code>).

   <p>The <code>BIOP</code> construction may also be used in declarations of the form

<pre class="example">     M x = BIOP 671
</pre>
   <p class="noindent">where <code>M</code> is any mode, most usefully a procedure with three or more
parameters.  The integer corresponds to the <code>decno</code> of an identifier
declaration.

   <p>If built-in operators or identifiers are to be used in other modules,
the integer after <code>BIOP</code> must be less than <code>Maxchar*maxchar</code> (see Appendix
5).

<h3 class="appendixsec"><a name="TOC129"></a>D.6 Generalised modes</h3>

<p>The primitive modes <code>XTYPE</code> and <code>YTYPE</code> have been introduced as
representations for any simple mode.  For the purpose of this
definition, a `simple' mode is one which contains no vectors, arrays
or references or which is a vector of such objects.  They may be used
in transput routines to avoid the overheads of straightening.  For
scope reasons objects of modes <code>XTYPE</code> and <code>YTYPE</code> may not be assigned.

   <p>The coercions associated with these modes are in the direction <code>YTYPE</code>
to <code>M</code> to <code>XTYPE</code> or <code>REF YTYPE</code> to <code>REF M</code> to <code>REF
XTYPE</code>, where <code>M</code> is any
simple mode.  The coercions from <code>REF YTYPE</code> and <code>REF M</code> may also remove
the initial <code>REF</code>; the compiler does not output an <code>xderef</code> in this case. 
Thus a procedure dealing with objects of various simple modes might
have the specification

<pre class="example">     PROC p = (VECTOR [] XTYPE x) YTYPE:
</pre>
   <p class="noindent">so that the parameters and result could be handled easily.  If
coercions in the opposite direction are required, the translator must
incorporate the relevant <code>BIOP</code>s.

   <p>The coercion to <code>XTYPE</code> is allowed before uniting, but as with i-structs
and vectors, <code>XTYPE</code> may exist side by side in the same union with a
simple mode or a <code>STRAIGHT</code>.  Possible ambiguities are resolved by
preference for minimum travel in the `simple to <code>XTYPE</code> to <code>STRAIGHT</code>'
direction.

<h3 class="appendixsec"><a name="TOC130"></a>D.7 Implementation dependent declarations</h3>

<p>One section of the text of the RS compiler is marked as
implementation-dependent and may be changed freely by implementors. 
The modes and values given below are used in the Algol 68 to C translator
implementation.

     <dl>
<dt><code>MODE ID = STRUCT 12 CHAR</code><dd>mode used to store an identifier, label, mode or operator
<br><dt><code>INT maxid = 12</code><dd>maximum significant length of (1)
<br><dt><code>INT maxchar = 64</code><dd>size of character set
<br><dt><code>MODE YM = STRUCT (INT album, index, version)</code><dd>description of module
<br><dt><code>MODE YS = INT</code><dd>description of spec
<br><dt><code>INT startrd = 1000</code><dd>integer added to routine numbers
<br><dt><code>INT startlib = 2000</code><dd>integer added to numbers of library identifiers
<br><dt><code>INT startkmp = 10000</code><dd>integer added to numbers of kept modeprocs
<br><dt><code>INT upbofmodes = 500</code><dd>size of modes array in compiler
<br><dt><code>INT upbofsidstack = 250</code><dd>size of analyser stack
<br><dt><code>INT maxistruct = 512</code><dd>maximum allowable size of indexable structures
<br><dt><code>CHAR dchar = "d", pchar = "p", nchar = "n"</code><dd>for <code>REAL</code> denotations in stream language
<br><dt><code>INT linesize = 160</code><dd>maximum length of a line of source-text
</dl>

   <div class="shortcontents">
<h2>Short Contents</h2>
<ul>
<li><a href="index.html#toc_TOC0">1 Introduction</a></li>
<li><a href="index.html#toc_TOC2">2 Stream Language Output</a></li>
<li><a href="index.html#toc_TOC7">3 Implementation</a></li>
<li><a href="index.html#toc_TOC8">4 The Compiler Shell</a></li>
<li><a href="index.html#toc_TOC15">5 Stream Language In Outline</a></li>
<li><a href="index.html#toc_TOC36">6 Stream language in detail</a></li>
<li><a href="index.html#toc_TOC89">7 Introduction</a></li>
<li><a href="index.html#toc_TOC90">8 The Source Language</a></li>
<li><a href="index.html#toc_TOC109">9 Stream Language</a></li>
<li><a href="index.html#toc_TOC117">Aldono A Values and representations of symbols</a></li>
<li><a href="index.html#toc_TOC119">Aldono B Fixed Mode Numbers</a></li>
<li><a href="index.html#toc_TOC120">Aldono C Numbering of standard prelude operators in <code>XOPER</code></a></li>
<li><a href="index.html#toc_TOC123">Aldono D Extensions To ALGOL 68</a></li>
</ul>
</div>

   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_TOC0" href="index.html#TOC0">1 Introduction</a>
<ul>
<li><a href="index.html#TOC1">1.1 The Source Language</a>
</li></ul>
<li><a name="toc_TOC2" href="index.html#TOC2">2 Stream Language Output</a>
<ul>
<li><a href="index.html#TOC3">2.1 The Structure Of Stream Language</a>
<li><a href="index.html#TOC4">2.2 The Reverse Polish Stack</a>
<li><a href="index.html#TOC5">2.3 The Creation Of New Objects</a>
<li><a href="index.html#TOC6">2.4 Assignment</a>
</li></ul>
<li><a name="toc_TOC7" href="index.html#TOC7">3 Implementation</a>
<li><a name="toc_TOC8" href="index.html#TOC8">4 The Compiler Shell</a>
<ul>
<li><a href="index.html#TOC9">4.1 Input Of Source Text</a>
<li><a href="index.html#TOC10">4.2 The <code>charset</code> Parameter</a>
<li><a href="index.html#TOC11">4.3 Values Of Symbols</a>
<li><a href="index.html#TOC12">4.4 The Lookup Procedure</a>
<li><a href="index.html#TOC13">4.5 Output Of Fault Messages</a>
<li><a href="index.html#TOC14">4.6 Output Of Stream Language</a>
</li></ul>
<li><a name="toc_TOC15" href="index.html#TOC15">5 Stream Language In Outline</a>
<ul>
<li><a href="index.html#TOC16">5.1 The Imperatives</a>
<ul>
<li><a href="index.html#TOC17">5.1.1 <code>XEDIT</code></a>
<li><a href="index.html#TOC18">5.1.2 <code>REF VECTOR [] MDE</code></a>
<li><a href="index.html#TOC19">5.1.3 <code>XDEC</code></a>
<li><a href="index.html#TOC20">5.1.4 <code>XROUTINE</code></a>
<li><a href="index.html#TOC21">5.1.5 <code>XSIZES</code></a>
<li><a href="index.html#TOC22">5.1.6 <code>XLOAD</code></a>
<li><a href="index.html#TOC23">5.1.7 <code>XCHARS</code></a>
<li><a href="index.html#TOC24">5.1.8 <code>XOPER</code></a>
<li><a href="index.html#TOC25">5.1.9 <code>XWARN</code></a>
<li><a href="index.html#TOC26">5.1.10 <code>XPRAG</code></a>
<li><a href="index.html#TOC27">5.1.11 <code>XCHARPOS</code></a>
<li><a href="index.html#TOC28">5.1.12 <code>XCONTROL</code></a>
</li></ul>
<li><a href="index.html#TOC29">5.2 Syntax Analysis Of Stream Language</a>
<ul>
<li><a href="index.html#TOC30">5.2.1 Abridged Syntax Of Stream Language</a>
<ul>
<li><a href="index.html#TOC31">5.2.1.1 Notation</a>
<li><a href="index.html#TOC32">5.2.1.2 Syntax rules</a>
<li><a href="index.html#TOC33">5.2.1.3 Skeleton translator &mdash; stage 1</a>
</li></ul>
</li></ul>
<li><a href="index.html#TOC34">5.3 The Reverse Polish Stack</a>
<ul>
<ul>
<li><a href="index.html#TOC35">5.3.0.1 Skeleton translator &mdash; stage 2</a>
</li></ul>
</li></ul>
</li></ul>
<li><a name="toc_TOC36" href="index.html#TOC36">6 Stream language in detail</a>
<ul>
<li><a href="index.html#TOC37">6.1 The Vector Of Modes &mdash; <code>REF VECTOR [] MDE modes</code></a>
<ul>
<li><a href="index.html#TOC38">6.1.1 Constituent Modes Of <code>MDE</code></a>
<li><a href="index.html#TOC39">6.1.2 <code>REF STRCT</code></a>
<li><a href="index.html#TOC40">6.1.3 <code>REF ISTRUCT</code></a>
<li><a href="index.html#TOC41">6.1.4 <code>REF VCTOR</code></a>
<li><a href="index.html#TOC42">6.1.5 <code>REF ARRAY</code></a>
<li><a href="index.html#TOC43">6.1.6 <code>REF UNN</code></a>
<li><a href="index.html#TOC44">6.1.7 <code>REF PROCP</code></a>
<li><a href="index.html#TOC45">6.1.8 <code>REF PRC</code></a>
<li><a href="index.html#TOC46">6.1.9 <code>REF STEN</code></a>
<li><a href="index.html#TOC47">6.1.10 <code>REF AMODE</code></a>
<li><a href="index.html#TOC48">6.1.11 <code>SAMEAS</code></a>
<li><a href="index.html#TOC49">6.1.12 <code>PRIMITIVE</code></a>
</li></ul>
<li><a href="index.html#TOC50">6.2 Identifier Declarations (<code>XIDDEC</code> from <code>XDEC</code>)</a>
<li><a href="index.html#TOC51">6.3 Routine Text Declarations, <code>XROUTINE</code></a>
<li><a href="index.html#TOC52">6.4 Label Declarations (<code>XLABDEC</code> from <code>XDEC</code>)</a>
<li><a href="index.html#TOC53">6.5 The Loading Imperative, <code>XLOAD</code>, And <code>XCHARS</code></a>
<ul>
<li><a href="index.html#TOC54">6.5.1 <code>BOOL</code></a>
<li><a href="index.html#TOC55">6.5.2 <code>INT</code></a>
<li><a href="index.html#TOC56">6.5.3 <code>REF LABEL</code></a>
<li><a href="index.html#TOC57">6.5.4 <code>STRUCT (INT Nse)</code></a>
<li><a href="index.html#TOC58">6.5.5 <code>XGEN  =  STRUCT (INT mode, BOOL loc)</code></a>
<li><a href="index.html#TOC59">6.5.6 <code>XNUMBER =  STRUCT (INT mode, REF VECTOR [] CHAR nu)</code></a>
<li><a href="index.html#TOC60">6.5.7 <code>XSTRING  =  STRUCT (INT strmode)</code></a>
<li><a href="index.html#TOC61">6.5.8 <code>XFORMAT  =  STRUCT (INT nochars, nocases, w)</code></a>
<li><a href="index.html#TOC62">6.5.9 <code>XALIEN  =  STRUCT (INT almode)</code></a>
<li><a href="index.html#TOC63">6.5.10 <code>XCODE  =  STRUCT (INT mode, nopars)</code></a>
<li><a href="index.html#TOC64">6.5.11 <code>XCHARS  =  STRUCT (INT nochars, base, REF VECTOR [] CHAR chars)</code></a>
</li></ul>
<li><a href="index.html#TOC65">6.6 Operations, <code>XOPER</code></a>
<ul>
<li><a href="index.html#TOC66">6.6.1 Standard prelude operators</a>
<li><a href="index.html#TOC67">6.6.2 Coercions and similar operations</a>
<li><a href="index.html#TOC68">6.6.3 Field selection and array indexing</a>
<li><a href="index.html#TOC69">6.6.4 Procedure calls</a>
<li><a href="index.html#TOC70">6.6.5 Assignment</a>
<li><a href="index.html#TOC71">6.6.6 Space finding</a>
<li><a href="index.html#TOC72">6.6.7 Straightening</a>
</li></ul>
<li><a href="index.html#TOC73">6.7 The Control Imperatives (<code>XCONTROL</code>)</a>
<ul>
<li><a href="index.html#TOC74">6.7.1 Fields of an <code>XCONTROL</code></a>
<li><a href="index.html#TOC75">6.7.2 The <code>props</code> field of an <code>XCONTROL</code></a>
<ul>
<li><a href="index.html#TOC76">6.7.2.1 General preliminary information</a>
<li><a href="index.html#TOC77">6.7.2.2 Dynamic result bits</a>
<li><a href="index.html#TOC78">6.7.2.3 Routine bits</a>
</li></ul>
<li><a href="index.html#TOC79">6.7.3 Other control imperatives</a>
<ul>
<li><a href="index.html#TOC80">6.7.3.1 <code>fn</code> = <code>xforall</code></a>
<li><a href="index.html#TOC81">6.7.3.2 <code>fn</code> = <code>xuchoice</code></a>
</li></ul>
</li></ul>
<li><a href="index.html#TOC82">6.8 The <code>XWARN</code> Imperative</a>
<li><a href="index.html#TOC83">6.9 The <code>XPRAG</code> Imperative</a>
<li><a href="index.html#TOC84">6.10 The <code>XCHARPOS</code> Imperative</a>
<li><a href="index.html#TOC85">6.11 An example of stream language</a>
<ul>
<li><a href="index.html#TOC86">6.11.1 Sizes</a>
<li><a href="index.html#TOC87">6.11.2 Modes</a>
<li><a href="index.html#TOC88">6.11.3 Other imperatives</a>
</li></ul>
</li></ul>
<li><a name="toc_TOC89" href="index.html#TOC89">7 Introduction</a>
<li><a name="toc_TOC90" href="index.html#TOC90">8 The Source Language</a>
<ul>
<li><a href="index.html#TOC91">8.1 keeplists</a>
<li><a href="index.html#TOC92">8.2 Simple declarations modules</a>
<li><a href="index.html#TOC93">8.3 Simple Programs</a>
<li><a href="index.html#TOC94">8.4 Nested Modules</a>
<li><a href="index.html#TOC95">8.5 Composition</a>
<ul>
<li><a href="index.html#TOC96">8.5.1 Example</a>
</li></ul>
<li><a href="index.html#TOC97">8.6 Partial Composition</a>
<li><a href="index.html#TOC98">8.7 Use of environmental packages</a>
<li><a href="index.html#TOC99">8.8 Declarations Modules In A Context</a>
<li><a href="index.html#TOC100">8.9 Provision For ALGOL 68 Standard Environment</a>
<li><a href="index.html#TOC101">8.10 The <code>VOID</code> Context</a>
<li><a href="index.html#TOC102">8.11 Summary Of Syntax And Semantics Of Modules</a>
<ul>
<li><a href="index.html#TOC103">8.11.1 <code>DECS</code> Module</a>
<li><a href="index.html#TOC104">8.11.2 <code>PROGRAM</code> Modules</a>
<li><a href="index.html#TOC105">8.11.3 Notes</a>
</li></ul>
<li><a href="index.html#TOC106">8.12 Composition Rules</a>
<li><a href="index.html#TOC107">8.13 Accessibility Of Kepts For Use In A Cc Module</a>
<li><a href="index.html#TOC108">8.14 Accessibility Of Kepts For Use In A DECS Module</a>
</li></ul>
<li><a name="toc_TOC109" href="index.html#TOC109">9 Stream Language</a>
<ul>
<li><a href="index.html#TOC110">9.1 The Current Compilation</a>
<li><a href="index.html#TOC111">9.2 Parameters Of The Compile Procedure</a>
<li><a href="index.html#TOC112">9.3 Information About Other Modules</a>
<li><a href="index.html#TOC113">9.4 A Model For A Running CC Module</a>
<li><a href="index.html#TOC114">9.5 Constructions In The Code</a>
<li><a href="index.html#TOC115">9.6 An Example Of Modular Compilation</a>
<ul>
<li><a href="index.html#TOC116">9.6.1 Stream Language Produced For The Above Modules</a>
</li></ul>
</li></ul>
<li><a name="toc_TOC117" href="index.html#TOC117">Aldono A Values and representations of symbols</a>
<ul>
<li><a href="index.html#TOC118">A.1 Note</a>
</li></ul>
<li><a name="toc_TOC119" href="index.html#TOC119">Aldono B Fixed Mode Numbers</a>
<li><a name="toc_TOC120" href="index.html#TOC120">Aldono C Numbering of standard prelude operators in <code>XOPER</code></a>
<ul>
<li><a href="index.html#TOC121">C.1 Monadic operators</a>
<li><a href="index.html#TOC122">C.2 Dyadic operators</a>
</li></ul>
<li><a name="toc_TOC123" href="index.html#TOC123">Aldono D Extensions To ALGOL 68</a>
<ul>
<li><a href="index.html#TOC124">D.1 Vectors and indexable structures</a>
<li><a href="index.html#TOC125">D.2 The <code>FORALL</code> statement</a>
<li><a href="index.html#TOC126">D.3 Straightening</a>
<li><a href="index.html#TOC127">D.4 Low level facilities</a>
<li><a href="index.html#TOC128">D.5 Built-in operators</a>
<li><a href="index.html#TOC129">D.6 Generalised modes</a>
<li><a href="index.html#TOC130">D.7 Implementation dependent declarations</a>
</li></ul>
</li></ul>
</div>

</body></html>

